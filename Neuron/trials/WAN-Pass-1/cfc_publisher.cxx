/* cfc_publisher.cxx

   A publication of data of type cfc

   This file is derived from code automatically generated by the rtiddsgen 
   command:

   rtiddsgen -language C++ -example <arch> cfc.idl

   Example publication of type cfc automatically generated by 
   'rtiddsgen'. To test them follow these steps:

   (1) Compile this file and the example subscription.

   (2) Start the subscription on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/cfc_subscriber <domain_id> <sample_count>
                
   (3) Start the publication on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/cfc_publisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and 
       multicast receive addresses via an environment variable or a file 
       (in the current working directory) called NDDS_DISCOVERY_PEERS. 
       
   You can run any number of publishers and subscribers programs, and can 
   add and remove them dynamically from the domain.

                                   
   Example:
        
       To run the example application on domain <domain_id>:
                          
       On Unix: 
       
       objs/<arch>/cfc_publisher <domain_id> o
       objs/<arch>/cfc_subscriber <domain_id> 
                            
       On Windows:
       
       objs\<arch>\cfc_publisher <domain_id>  
       objs\<arch>\cfc_subscriber <domain_id>    

       
modification history
------------ -------       
* Use only UDP for transport.

* Create and configure flowcontroller

* Simulate a bursty writer
*/

#include <stdio.h>
#include <stdlib.h>
#include "ndds/ndds_cpp.h"
#include "cfc.h"
#include "cfcSupport.h"

#include <string.h>

extern unsigned long router_ip;
extern unsigned long domain;
extern unsigned long bitrate;
extern char topicname[100];
extern char partname[100];
extern bool bUseUDP;
extern bool parsecmd(char**argv, int argc);

/* Delete all entities */
static int publisher_shutdown(
    DDSDomainParticipant *participant)
{
    DDS_ReturnCode_t retcode;
    int status = 0;

    if (participant != NULL) {
        retcode = participant->delete_contained_entities();
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_contained_entities error %d\n", retcode);
            status = -1;
        }

        retcode = DDSTheParticipantFactory->delete_participant(participant);
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_participant error %d\n", retcode);
            status = -1;
        }
    }

    /* RTI Data Distribution Service provides finalize_instance() method for
       people who want to release memory used by the participant factory
       singleton. Uncomment the following block of code for clean destruction of
       the participant factory singleton. */
/*
    retcode = DDSDomainParticipantFactory::finalize_instance();
    if (retcode != DDS_RETCODE_OK) {
        printf("finalize_instance error %d\n", retcode);
        status = -1;
    }
*/

    return status;
}

extern "C" int publisher_main(int domainId, int sample_count)
{
    DDSDomainParticipant *participant = NULL;
    DDSPublisher *publisher = NULL;
    DDSTopic *topic = NULL;
    DDSDataWriter *writer = NULL;
    cfcDataWriter * cfc_writer = NULL;
    cfc *instance = NULL;
    DDS_ReturnCode_t retcode;
    DDS_InstanceHandle_t instance_handle = DDS_HANDLE_NIL;
    const char *type_name = NULL;
    int count = 0;  
    struct DDS_Duration_t send_period = {1,0};

    //// Start changes for Custom_Flowcontroller

    /* Get default participant QoS to customize */
    DDS_DomainParticipantQos participant_qos;
    retcode = DDSTheParticipantFactory->get_default_participant_qos(participant_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_participant_qos error\n");
        return -1;
    }

    // By default, data will be sent via shared memory _and_ UDPv4.  Because
    // the flowcontroller limits writes across all interfaces, this halves the
    // effective send rate.  To avoid this, we enable only the UDPv4 transport
    participant_qos.transport_builtin.mask = DDS_TRANSPORTBUILTIN_UDPv4;

    /* To create participant with default QoS, use DDS_PARTICIPANT_QOS_DEFAULT
       instead of participant_qos */
    participant = DDSTheParticipantFactory->create_participant(
        domainId, participant_qos, 
        NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (participant == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// End changes for Custom_Flowcontroller

    /* To customize publisher QoS, use
       participant->get_default_publisher_qos() */
    publisher = participant->create_publisher(
        DDS_PUBLISHER_QOS_DEFAULT, NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (publisher == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Register type before creating topic */
    type_name = cfcTypeSupport::get_type_name();
    retcode = cfcTypeSupport::register_type(
        participant, type_name);
    if (retcode != DDS_RETCODE_OK) {
        printf("register_type error %d\n", retcode);
        publisher_shutdown(participant);
        return -1;
    }

    /* To customize topic QoS, use
       participant->get_default_topic_qos() */
    topic = participant->create_topic(
        "Example cfc",
        type_name, DDS_TOPIC_QOS_DEFAULT, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (topic == NULL) {
        printf("create_topic error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// Start changes for Custom_Flowcontroller

    const char* cfc_name = "Custom_Flowcontroller";

    // Create and configure flowcontroller properties
    DDS_FlowControllerProperty_t custom_fcp;
    retcode = participant->get_default_flowcontroller_property(custom_fcp);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_flowcontroller_property error \n");
        return -1;
    }

    // Don't allow too many tokens to accumulate
    custom_fcp.token_bucket.max_tokens = 
        custom_fcp.token_bucket.tokens_added_per_period = 2;
    custom_fcp.token_bucket.tokens_leaked_per_period = DDS_LENGTH_UNLIMITED;

    // 100ms
    custom_fcp.token_bucket.period.sec = 0;
    custom_fcp.token_bucket.period.nanosec = 100000000;

    // The sample size is 1000, but the minimum bytes_per_token is 1024.
    // Furthermore, we want to allow some overhead.
    custom_fcp.token_bucket.bytes_per_token = 1024;

    // So, in summary, each token can be used to send about one message,
    // and we get 2 tokens every 100ms, so this limits transmissions to
    // about 20 messages per second.

    // Create flowcontroller and set properties
    DDSFlowController* cfc = NULL;
    cfc = participant->create_flowcontroller(DDS_String_dup(cfc_name), custom_fcp);
    if (cfc == NULL) {
        printf("create_flowcontroller error\n");
        return -1;
    }

    /* Get default datawriter QoS to customize */
    DDS_DataWriterQos datawriter_qos;
    retcode = publisher->get_default_datawriter_qos(datawriter_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_datawriter_qos error\n");
        return -1;
    }
 
    // As an alternative to increasing history depth, we can just
    // set the qos to keep all samples
//RMW Changed to keep_last    datawriter_qos.history.kind = DDS_KEEP_ALL_HISTORY_QOS;
    datawriter_qos.history.kind = DDS_KEEP_LAST_HISTORY_QOS;
    datawriter_qos.history.depth = 10;

    // Set flowcontroller for datawriter
    datawriter_qos.publish_mode.kind = DDS_ASYNCHRONOUS_PUBLISH_MODE_QOS;
    datawriter_qos.publish_mode.flow_controller_name = DDS_String_dup(cfc_name);

    /* To create datawriter with default QoS, use DDS_DATAWRITER_QOS_DEFAULT
       instead of datawriter_qos */
    writer = publisher->create_datawriter(
        topic, datawriter_qos, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (writer == NULL) {
        printf("create_datawriter error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// End changes for Custom_Flowcontroller

    cfc_writer = cfcDataWriter::narrow(writer);
    if (cfc_writer == NULL) {
        printf("DataWriter narrow error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Create data sample for writing */
    instance = cfcTypeSupport::create_data();
    if (instance == NULL) {
        printf("cfcTypeSupport::create_data error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* For data type that has key, if the same instance is going to be
       written multiple times, initialize the key here
       and register the keyed instance prior to writing */
/*
    instance_handle = cfc_writer->register_instance(*instance);
*/

    // The concept here is to send a "chunk" of data rather quickly and in a fairly bursty fashion.
    // If a bitrate of 768kbps is desired, this means 96k bytes of data are sent in one second.
    // In order to aid in making it bursty, we'll divide that packet into 4 equal chunks and send them
    // into the queue one right after another.
    //
    // The flow controller will level out the sending of that traffic on the wire.
    //
    static char pattern[37] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    unsigned char *pDatum;
    int bytestosend = bitrate/8;
    pDatum = (unsigned char*) malloc(bytestosend);         // Total memory is bps/8 to get to bytes per second.

    // Fill datum buffer with pattern.
    for (int i=0; i<(bytestosend); i++)
      pDatum[i] = pattern[i%36];

    char hostnm[64];
    bzero(hostnm,64);

    int err = gethostname(hostnm, 63);

    if (err)
      printf("ERROR in gethostname = %d", err);
    else
      printf("Hostname for 'from' field is: %s\n", hostnm);

    strcpy(instance->from, hostnm);

    char stamp[100];

    /* Main loop */
    for (count=0; (sample_count == 0) || (count < sample_count); ++count) {

        //// Changes for Custom_Flowcontroller
        // Simulate bursty writer
        NDDSUtility::sleep(send_period);

        int offset=0;
        int chunks=4;

        for (int i = 0; i < chunks; ++i) {
            int sample = count*chunks + i;
            printf("Writing payload 'chunk' # %d - \n", sample);
            instance->x = sample;
            memset(instance->str, 1, 999);
            instance->str[999] = 0;

            // Dump the payload chunk - iteratively for each of the 4 chunks.
            instance->payload.from_array(pDatum+offset, bytestosend/chunks);
            sprintf(stamp, "%s - chunk#%d", hostnm, sample);
            memcpy(pDatum+offset, stamp, strlen(stamp));

            offset += bytestosend/chunks;

            retcode = cfc_writer->write(*instance, instance_handle);
            if (retcode != DDS_RETCODE_OK) {
                printf("write error %d\n", retcode);
            }
        }
    }

    NDDSUtility::sleep(send_period);
    free(pDatum);

/*
    retcode = cfc_writer->unregister_instance(
        *instance, instance_handle);
    if (retcode != DDS_RETCODE_OK) {
        printf("unregister instance error %d\n", retcode);
    }
*/

    /* Delete data sample */
    retcode = cfcTypeSupport::delete_data(instance);
    if (retcode != DDS_RETCODE_OK) {
        printf("cfcTypeSupport::delete_data error %d\n", retcode);
    }

    /* Delete all entities */
    return publisher_shutdown(participant);
}

#if defined(RTI_WINCE)
int wmain(int argc, wchar_t** argv)
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */ 
    
    if (argc >= 2) {
        domainId = _wtoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = _wtoi(argv[2]);
    }

     /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */
    
    return publisher_main(domainId, sample_count);
}
 
#elif !(defined(RTI_VXWORKS) && !defined(__RTP__)) && !defined(RTI_PSOS)
int main(int argc, char *argv[])
{
    int sample_count = 0; /* infinite loop */

    /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */

    if (parsecmd(argv, argc))
      return publisher_main(domain, sample_count);
    else
    {
        printf("Error parsing command line parameters.\n");
        return -1;
    }

    // Check for errant command situations.
    if (!bitrate)
    {
      printf("Bitrate setting is REQUIRED for publisher. Please use -b <bitrate> option.\n");
      return -1;
    }

}
#endif
