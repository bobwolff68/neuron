/* cfc_publisher.cxx

   A publication of data of type cfc

   This file is derived from code automatically generated by the rtiddsgen 
   command:

   rtiddsgen -language C++ -example <arch> cfc.idl

   Example publication of type cfc automatically generated by 
   'rtiddsgen'. To test them follow these steps:

   (1) Compile this file and the example subscription.

   (2) Start the subscription on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/cfc_subscriber <domain_id> <sample_count>
                
   (3) Start the publication on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/cfc_publisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and 
       multicast receive addresses via an environment variable or a file 
       (in the current working directory) called NDDS_DISCOVERY_PEERS. 
       
   You can run any number of publishers and subscribers programs, and can 
   add and remove them dynamically from the domain.

                                   
   Example:
        
       To run the example application on domain <domain_id>:
                          
       On Unix: 
       
       objs/<arch>/cfc_publisher <domain_id> o
       objs/<arch>/cfc_subscriber <domain_id> 
                            
       On Windows:
       
       objs\<arch>\cfc_publisher <domain_id>  
       objs\<arch>\cfc_subscriber <domain_id>    

       
modification history
------------ -------       
* Use only UDP for transport.

* Create and configure flowcontroller

* Simulate a bursty writer
*/

#include <stdio.h>
#include <stdlib.h>
#include "ndds/ndds_cpp.h"
#include "cfc.h"
#include "cfcSupport.h"
#include <string.h>
#include "choices.h"
#include "cfc_transport_config.h"

#include <assert.h>

#define TCP_BIND_PORT 7500

extern unsigned long router_ip;
extern unsigned long domain;
extern unsigned long bitrate;
extern char topicname[100];
extern char partname[100];
extern char stunLocator[100];
extern char peerList[10][100];
extern char stunLivePeriodStr[20];
extern char stunRetranIntvlStr[20];
extern char stunNumRetransStr[20];
extern int  wanID;
extern bool bUseUDP;
extern bool bEnableMonitor;
extern bool bUseDefaultPeers;
extern bool bUseFlowCtrl;
extern int	chunks;
extern bool parsecmd(char**argv, int argc);

extern bool isResized;

/* Delete all entities */
static int publisher_shutdown(
    DDSDomainParticipant *participant)
{
    DDS_ReturnCode_t retcode;
    int status = 0;

    if (participant != NULL) {
        retcode = participant->delete_contained_entities();
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_contained_entities error %d\n", retcode);
            status = -1;
        }

        retcode = DDSTheParticipantFactory->delete_participant(participant);
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_participant error %d\n", retcode);
            status = -1;
        }
    }

    /* RTI Data Distribution Service provides finalize_instance() method for
       people who want to release memory used by the participant factory
       singleton. Uncomment the following block of code for clean destruction of
       the participant factory singleton. */
/*
    retcode = DDSDomainParticipantFactory::finalize_instance();
    if (retcode != DDS_RETCODE_OK) {
        printf("finalize_instance error %d\n", retcode);
        status = -1;
    }
*/

    return status;
}

extern "C" int publisher_main(int domainId, int sample_count)
{
    DDSDomainParticipant *participant = NULL;
    DDS_DomainParticipantQos participant_qos;
    DDSPublisher *publisher = NULL;
    DDSTopic *topic = NULL;
    DDSDataWriter *writer = NULL;
    cfcDataWriter * cfc_writer = NULL;
    cfc *instance = NULL;
    DDS_ReturnCode_t retcode;
    DDS_InstanceHandle_t instance_handle = DDS_HANDLE_NIL;
    const char *type_name = NULL;
    const char* cfc_name = "Custom_Flowcontroller";
    int count = 0;  
    struct DDS_Duration_t send_period = {1,0};

    //// Start changes for Custom_Flowcontroller

    /* Get default participant QoS to customize */
    if(bUseUDP)
    	participant_qos = DPQos_with_UDPWAN(stunLocator,wanID,stunLivePeriodStr,stunRetranIntvlStr, 
    										stunNumRetransStr,bEnableMonitor);
    else if(bUseDefaultPeers)
    {
    	printf("Default Peers Mode...\n");
    	retcode = DDSTheParticipantFactory->get_default_participant_qos(participant_qos);
    	if (retcode != DDS_RETCODE_OK) 
    	{
          	printf("get_default_participant_qos error\n");
        	return -1;
    	}
    	if(bEnableMonitor)
    	{
    		if(participant_qos_with_monitoring_enabled(participant_qos)<0)
    			return -1;
    	}
    }
    else
    	participant_qos = DPQos_with_TCPLAN(TCP_BIND_PORT,bEnableMonitor);
    /*retcode = DDSTheParticipantFactory->get_default_participant_qos(participant_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_participant_qos error\n");
        return -1;
    }

    // By default, data will be sent via shared memory _and_ UDPv4.  Because
    // the flowcontroller limits writes across all interfaces, this halves the
    // effective send rate.  To avoid this, we enable only the UDPv4 transport
    participant_qos.transport_builtin.mask = DDS_TRANSPORTBUILTIN_UDPv4;*/

    /* To create participant with default QoS, use DDS_PARTICIPANT_QOS_DEFAULT
       instead of participant_qos */
    DDS_DomainParticipantQos_setup_udpv4_message_size_max(participant_qos,MSG_SIZE_MAX_BYTES_STR);
    participant = DDSTheParticipantFactory->create_participant(
        domainId, participant_qos, 
        NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (participant == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

	// Add peers from peer list
	if(!bUseDefaultPeers)
	{
		retcode = participant->add_peer(peerList[0]);
    	if (retcode != DDS_RETCODE_OK) {
    	    printf("add_peer() error %d\n", retcode);
    	    publisher_shutdown(participant);
    	    return -1;
    	}
    }
    //// End changes for Custom_Flowcontroller

    /* To customize publisher QoS, use
       participant->get_default_publisher_qos() */
    publisher = participant->create_publisher(
        DDS_PUBLISHER_QOS_DEFAULT, NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (publisher == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Register type before creating topic */
    type_name = cfcTypeSupport::get_type_name();
    retcode = cfcTypeSupport::register_type(
        participant, type_name);
    if (retcode != DDS_RETCODE_OK) {
        printf("register_type error %d\n", retcode);
        publisher_shutdown(participant);
        return -1;
    }

    /* To customize topic QoS, use
       participant->get_default_topic_qos() */
    topic = participant->create_topic(
        "Example cfc",
        type_name, DDS_TOPIC_QOS_DEFAULT, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (topic == NULL) {
        printf("create_topic error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// Start changes for Custom_Flowcontroller
    // Create and configure flowcontroller properties
    if(bUseFlowCtrl)
    {
    	DDS_FlowControllerProperty_t custom_fcp;
    	retcode = participant->get_default_flowcontroller_property(custom_fcp);
    	if (retcode != DDS_RETCODE_OK) {
    	    printf("get_default_flowcontroller_property error \n");
    	    return -1;
    	}

    	// Don't allow too many tokens to accumulate
    	custom_fcp.token_bucket.max_tokens = 
    	    custom_fcp.token_bucket.tokens_added_per_period = 1;
    	custom_fcp.token_bucket.tokens_leaked_per_period = DDS_LENGTH_UNLIMITED;

    	// 100ms
    	custom_fcp.token_bucket.period.sec = 0;
    	custom_fcp.token_bucket.period.nanosec = 9000000;

    	// The sample size is 1000, but the minimum bytes_per_token is 1024.
    	// Furthermore, we want to allow some overhead.
    	custom_fcp.token_bucket.bytes_per_token = 1024;

    	// So, in summary, each token can be used to send about one message,
    	// and we get 2 tokens every 100ms, so this limits transmissions to
    	// about 20 messages per second.

    	// Create flowcontroller and set properties
    	DDSFlowController* cfc = NULL;
    	cfc = participant->create_flowcontroller(DDS_String_dup(cfc_name), custom_fcp);
    	if (cfc == NULL) {
    	    printf("create_flowcontroller error\n");
    	    return -1;
    	}
	}
	
    /* Get default datawriter QoS to customize */
    DDS_DataWriterQos datawriter_qos;
    retcode = publisher->get_default_datawriter_qos(datawriter_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_datawriter_qos error\n");
        return -1;
    }
 
    // As an alternative to increasing history depth, we can just
    // set the qos to keep all samples
//RMW Changed to keep_last    datawriter_qos.history.kind = DDS_KEEP_ALL_HISTORY_QOS;
    datawriter_qos.history.kind = DDS_KEEP_LAST_HISTORY_QOS;
    datawriter_qos.history.depth = 50;

    //RMW - changed to try best efforts + flow controller. Not sure if this is valid or not.
    datawriter_qos.reliability.kind = DDS_BEST_EFFORT_RELIABILITY_QOS;
    
	if(bUseFlowCtrl)
	{
    	// Set flowcontroller for datawriter
    	datawriter_qos.publish_mode.kind = DDS_ASYNCHRONOUS_PUBLISH_MODE_QOS;
		// datawriter_qos.publish_mode.kind = DDS_SYNCHRONOUS_PUBLISH_MODE_QOS;
    	datawriter_qos.publish_mode.flow_controller_name = DDS_String_dup(cfc_name);
	}
    /* To create datawriter with default QoS, use DDS_DATAWRITER_QOS_DEFAULT
       instead of datawriter_qos */
    writer = publisher->create_datawriter(
        topic, datawriter_qos, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (writer == NULL) {
        printf("create_datawriter error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// End changes for Custom_Flowcontroller

    cfc_writer = cfcDataWriter::narrow(writer);
    if (cfc_writer == NULL) {
        printf("DataWriter narrow error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Create data sample for writing */
    instance = cfcTypeSupport::create_data();
    if (instance == NULL) {
        printf("cfcTypeSupport::create_data error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* For data type that has key, if the same instance is going to be
       written multiple times, initialize the key here
       and register the keyed instance prior to writing */
/*
    instance_handle = cfc_writer->register_instance(*instance);
*/

    // The concept here is to send a "chunk" of data rather quickly and in a fairly bursty fashion.
    // If a bitrate of 768kbps is desired, this means 96k bytes of data are sent in one second.
    // In order to aid in making it bursty, we'll divide that packet into 4 equal chunks and send them
    // into the queue one right after another.
    //
    // The flow controller will level out the sending of that traffic on the wire.
    //
    static char pattern[37] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    unsigned char *pDatum;
    int offset=0;
    if(chunks>1)
    {
    	send_period.sec = 0;
    	send_period.nanosec = 1000000000/chunks;
    }
    int bytestosend = bitrate/8;
    pDatum = (unsigned char*) malloc(bytestosend); // Total memory is bps/8 to get to bytes per second.

    // Need to round-down appropriately the actual number of bytes to send to be mod-4 (mod-chunks).
    // Otherwise we will have a "straddling problem" at the end of a send that could cause
    // memory corruption.
    bytestosend = bytestosend - (bytestosend % chunks);
      
    // Fill datum buffer with pattern.
    for (int i=0; i<(bytestosend); i++)
      pDatum[i] = pattern[i%36];

    char hostnm[64];
    bzero(hostnm,64);

    int err = gethostname(hostnm, 63);

    if (err)
      printf("ERROR in gethostname = %d", err);
    else
      printf("Hostname for 'from' field is: %s\n", hostnm);

    strcpy(instance->from, hostnm);

    char stamp[100];

    /* Main loop */
    for (count=0; (sample_count == 0) || (count < sample_count); ++count) {

        //// Changes for Custom_Flowcontroller
        // Simulate bursty writer
	
	offset = 0;

        for (int i = 0; i < chunks; ++i) {
            int sample = count*chunks + i;
            printf("Writing payload 'chunk' # %d - \n", sample);
            instance->x = sample;
            memset(instance->str, 1, 999);
            instance->str[999] = 0;

            // Dump the payload chunk - iteratively for each of the 4 chunks.
            instance->payload.from_array(pDatum+offset, bytestosend/chunks);
            sprintf(stamp, "%s - chunk#%d", hostnm, sample);
            strncpy(instance->timestamp, stamp, (strlen(stamp)<63)?strlen(stamp):63);

            offset += bytestosend/chunks;
			NDDSUtility::sleep(send_period);
	
            retcode = cfc_writer->write(*instance, instance_handle);
            if (retcode != DDS_RETCODE_OK) {
                printf("write error %d\n", retcode);
            }
        }
    }

    NDDSUtility::sleep(send_period);
    free(pDatum);

/*
    retcode = cfc_writer->unregister_instance(
        *instance, instance_handle);
    if (retcode != DDS_RETCODE_OK) {
        printf("unregister instance error %d\n", retcode);
    }
*/

    /* Delete data sample */
    retcode = cfcTypeSupport::delete_data(instance);
    if (retcode != DDS_RETCODE_OK) {
        printf("cfcTypeSupport::delete_data error %d\n", retcode);
    }

    /* Delete all entities */
    return publisher_shutdown(participant);
}

#if defined(RTI_WINCE)
int wmain(int argc, wchar_t** argv)
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */ 
    
    if (argc >= 2) {
        domainId = _wtoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = _wtoi(argv[2]);
    }

     /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */
    
    return publisher_main(domainId, sample_count);
}
 
#elif !(defined(RTI_VXWORKS) && !defined(__RTP__)) && !defined(RTI_PSOS)

int main(int argc, char *argv[])
{
    int sample_count = 0; /* infinite loop */

    // Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
#if 0
    choices kb;
    updates *screen;
    screen = new updates;
#else
    updates *screen;
    screen = new updates;
    nodelay(stdscr, true);
#endif


    sleep(2);
    screen->LogLine("Hello there. CRLF buried here.\nTest continuation. NOCRLF.");
    screen->LogLine("3: 2nd log item. No CRLF.");
    screen->LogLine("4: 3rd log item. With CRLF at end.\n");
    screen->LogLine("5: 4th NOCRLF.");
    screen->LogLine("6: 5th NOCRLF.");
    screen->LogLine("7: 6th NOCRLF.");
    screen->LogLine("8: 7th with buried CRLf.\nHere's continuation...NOCRLF.");
    screen->LogLine("10: One to grow on. With CRLF.\n");

    screen->LogLine("Done playing...");

    while (1)
      {
      int c;
      char output[20];

      if (isResized)
        {
          char sizes[100];
          isResized = false;

          screen->ResizeLogWin();
        }

        screen->Reverse(true);
        screen->putStringAt(0, screen->getCurMaxY()/2 - 2, "Press a key or (Q/X) to exit.");
        screen->Reverse(false);

        usleep(250000);
//        c = screen->processChar(kb.getchar());
        c = screen->processChar(getch());            // blocking 'get'
        if (c > 0)
        {
          if (c=='q' || c=='Q' || c=='x' || c=='X')
            break;

          switch(c)
          {
          case 'L':
            screen->LogLine("Logging another line just to show off...");
            break;

          case 'u':
          case 'U':
            screen->LogUp();
            break;

          case 'd':
          case 'D':
            screen->LogDown();
            break;

          case '1':
            screen->setItemValue("BigFatHeaderName", 2500000);
            screen->printItems();
            break;

          case '2':
            screen->setItemValue("MediumHeader", 150000);
            screen->printItems();
            break;

          case '3':
            screen->setItemValue("Small", 453);
            screen->printItems();
            break;

          case '4':
            screen->setItemValue("Xsml", 128000);
            screen->printItems();
            break;

          case '5':
            screen->setItemValue("Bitrate", 1024000);
            screen->printItems();
            break;

          case '6':
            screen->setItemValue("Chunks", 4);
            screen->printItems();
            break;

          case '7':
            screen->setItemValue("FlowControl", 32);
            screen->printItems();
            break;

          default:
            break;
          }

          screen->Standout(true);
          sprintf(output, "Found: %c", c);
          screen->putStringAt(0, screen->getCurMaxY()/2 - 1, output);
          screen->Standout(false);
        }
        else
          screen->putStringAt(0, screen->getCurMaxY()/2 - 1, "None  ");
      }

    delete screen;
//    return(1);

    if (parsecmd(argv, argc))
    {
      // Check for errant command situations.
      if (!bitrate)
      {
        printf("Bitrate setting is REQUIRED for publisher. Please use -b <bitrate> option.\n");
        return -1;
      }

      return publisher_main(domain, sample_count);
    }
    else
    {
        printf("Error parsing command line parameters.\n");
        return -1;
    }

}
#endif
