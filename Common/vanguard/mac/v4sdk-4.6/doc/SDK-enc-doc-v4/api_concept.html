<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="style.css" REL="stylesheet" TYPE="text/css">
</head>
    <BODY BGCOLOR="#FFFFFF">

	<a href="http://www.vsofts.com/" target="top">
		<img src="vssh-codec-logo.gif" border="none">
	</a>
	<p style="margin-top: 0px; font-size: smaller;">
		<a href="main.html" style="text-decoration:none; color: #252E78; ">
		VSS H.264 Encoder SDK v4
		</a>
	</p>
<!-- header.html -->

<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="api_concept">API Concept </a></h1>The new generation of the Codec is fully multi-threaded and efficiently utilizes system objects for threading operations.
Application program interface of the codec v.4 is intended to fit quite different requirements and types of applications: from a simple console utility to asynchronous DirectShow (or DMO) multi-threaded filter. That’s why we provide both synchronous and asynchronous versions of input / output functions.
<h1>Encoder API</h1>
All API functions are multi-threaded, i.e. could be called from different application threads with data consistency guarantee. Our approach is that every function returns integer value – return code – which signals result of the operation. Zero value (VSSH_OK) means that function call succeeded. Negative values are fatal error codes. Positive values could be considered as warnings; it is dependent on particular function behavior.
Output values are to be returned via function arguments.
<h2>General functions</h2>
<h3>1. Create encoder instance</h3>
<code class="src">v4e_open(handle, settings)</code>
<h3>2.	Destroy encoder instance</h3>
<code class="src">v4e_close(handle)</code>
This function will impose encoder flush event if not yet flushed – to release output thread of application if it is waiting for NAL unit. After that it will stop all the worker threads and free memory and system resources.
<h2>Input / Output synchronous model</h2>
Synchronous model is targeted for console-like application with active input, i.e. file reading. Encoder input would block when all slots are busy. Output is not blocked and is intended to be called after every input frame. On end of file application flushes the encoder and EOS flag on encoder output signals end of operation.
<h3>1.	Put raw uncompressed frame</h3>
<code class="src">v4e_set_frame(handle, frame);</code>
This blocking function waits for a next free encoder input slot, then sends given frame to encoder and waits for the frame to be released, so that the frame could be immediately reused again. Application is supposed to use single input frame.
<h3>2.	Flush the stream</h3>
<code class="src">v4e_set_flush(handle);</code>
This function signals encoder to process all the pending frames and return all NAL units and EOS flag at the very end. Anyway the encoder is still running and could be used again without stop / start operation. EOS state will be reset after next <em>v4e_set_frame()</em> call.
<h3>3.	Extract next NAL unit (media sample)</h3>
<code class="src">v4e_get_nal(handle, ms);</code>
This function does not block. It checks whether next NAL unit is available. Three return codes are possible: a) No data; b) NAL unit ready; 3) EOS (end of stream). EOS flag on function output also means that there are no more NAL units available after flushing.
<h2>Asynchronous model</h2>
Asynchronous model is designed for separated input / output threads application architecture and allows for maximum performance and several cores using. Asynchronous input API provides blocking and non-blocking behaviors for maximum flexibility. Asynchronous input approach requires application-provided frame release callback function because frames are to be released asynchronously. Also it implies an application to use several input frames in order to allow for parallel input frame processing. The recommended number of input frames on the application level is specified by “NUM_RGB_FRAMES” define.
<h3>1.	Create encoder instance</h3>
<code class="src">v4e_open_ex(handle, settings, frame_release);</code>
Caller must provide “frame release callback” function when creating encoder instance to receive “release” events signaling that particular frame is no more used and thus could be reused or freed by application. It is the caller responsibility to guarantee that frames are not reused before release event.
<h3>2.	Put raw uncompressed frame</h3>
<code class="src">v4e_set_frame_ex(handle, frame, blocking);</code>
The function sends given frame to encoder asynchronously.
If blocking argument is zero (blocking not allowed) and there are no more free input slots in encoder core, this function returns appropriate error code, otherwise it will wait for a next free encoder input slot.

<h2>Changing parameters on-the-fly</h2>
It's allowed to change the following encoding parameters after encoder start (on-the-fly):
<ul>
<li>frame rate and bit rate - see <code class="src">v4e_change_bitrate()</code> and <code class="src">v4e_change_bitrate_and_framerate()</code> API functions
<li>individual frame/slice parameters (slice type, QP) - see <code class="src">frame_modifier_t</code> structure
</ul>
 </div>

<!-- footer.html -->
	<hr>

	<p style="font-size: smaller; text-align: right">
		&#169 <a href="http://www.vsofts.com/" target="_blank">Vanguard Software Solutions Inc</a> 1995-2011 - All rights reserved.
	</p>

	</body>
</html>
