<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="style.css" REL="stylesheet" TYPE="text/css">
</head>
    <BODY BGCOLOR="#FFFFFF">

	<a href="http://www.vsofts.com/" target="top">
		<img src="vssh-codec-logo.gif" border="none">
	</a>
	<p style="margin-top: 0px; font-size: smaller;">
		<a href="main.html" style="text-decoration:none; color: #252E78; ">
		VSS H.264 Encoder SDK v4
		</a>
	</p>
<!-- header.html -->

<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="sample_transcode">Sample Transcoder </a></h1>Sample ParallelStream H.264 to H.264 transcoder <div class="fragment"><pre class="fragment">
<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE //to avoid warning C4996: 'fopen' was declared deprecated</span>
<span class="preprocessor"></span>
<span class="comment">// codec headers</span>
<span class="preprocessor">#include "<a class="code" href="v4e__api_8h.html" title="Encoder public API.">v4e_api.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="v4d__api_8h.html" title="VSofts H.264/AVC Encoder public API.">v4d_api.h</a>"</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;assert.h&gt;</span>

<span class="comment">// enable CRT debug for memory leak detection etc. (available under Windows only)</span>
<span class="preprocessor">#if defined(WIN32) &amp;&amp; defined(DEBUG) &amp;&amp; !defined(__GNUC__)</span>
<span class="preprocessor"></span><span class="preprocessor">#define _CRT_DEBUG_</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#ifdef _CRT_DEBUG_</span>
<span class="preprocessor"></span><span class="preprocessor">    #include &lt;crtdbg.h&gt;</span>
<span class="comment">//  #include &lt;vld.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include "<a class="code" href="v4timer_8h.html" title="high resolution timer">v4timer.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="v4info_8h.html" title="Codec information access example.">v4info.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="v4args_8h.html" title="command line arguments parsing routines">v4args.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="v4file_8h.html" title="file i/o operations verbose output support">v4file.h</a>"</span>


<span class="preprocessor">#define MAX_FILE_NAME 1024</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>transcode_data_t
{
    <span class="comment">//Public members, set from command line or cfg file</span>
    <span class="comment">//Input</span>
    <span class="keywordtype">int</span> frame_width; <span class="comment">//Dimensions of the highest resolution for encoder</span>
    <span class="keywordtype">int</span> frame_height; <span class="comment">//this resolution can differ from resolution of input stream</span>
    <span class="keywordtype">int</span> max_frames; <span class="comment">//max number of input frames to process</span>
    <span class="keywordtype">int</span> frame_start; <span class="comment">//start frame to code</span>
    <span class="keywordtype">int</span> mt_dec; <span class="comment">//mt parameter for decoder</span>
    <span class="keywordtype">int</span> transcode; <span class="comment">//transcode mode (0 - simple recode; 1 - transcode</span>
    <span class="keywordtype">int</span> verbose; <span class="comment">//level of verbose messages (0/1/2)"</span>
    <span class="keywordtype">char</span> *input_file;  <span class="comment">//Name of input h.264 file</span>
    <span class="keywordtype">char</span> *orig_file;   <span class="comment">//Name of input original yuv-file. used to substitude decoded pixels by original one</span>
    <span class="keywordtype">char</span> *output_file; <span class="comment">//Name of output h.264 file</span>
    <span class="keywordtype">char</span> *config_file; <span class="comment">//Name of encoding gfg file</span>
    <a class="code" href="structv4e__settings__t.html" title="All encoder settings.">v4e_settings_t</a> enc_settings; <span class="comment">//encoder settings</span>
    <span class="comment">//Output</span>
    <span class="keywordtype">int</span> status; <span class="comment">//current transcoding status. 0 - means all OK; or error code. </span>


    <span class="comment">//Private members used during transcoding</span>
    FILE *<a class="code" href="v4file_8h.html#15c1ffab0926c9d750ff119cca0285b0">file_in</a>; <span class="comment">//input h.264 file </span>
    FILE *orig_in; <span class="comment">//input yuv file. Must be yuv of the same size as decoded yuv </span>
    byte *orig_pixels;   <span class="comment">//buffer for original pixels</span>
    <span class="keywordtype">int</span> orig_pixels_size;
    <span class="keywordtype">int</span> num_out_files; <span class="comment">//number of output h.264 files (calculated fro encoder settings)</span>
    FILE *files_out[<a class="code" href="v4__types_8h.html#3bd149976fc443d2734093ae6b7ad6a7" title="Maximum number of AVC streams in multistream encoding mode.">MAX_AVC_STREAMS</a>]; <span class="comment">//output files; several files in case of Parallelstream encoding </span>
    <a class="code" href="structv4d__settings__t.html">v4d_settings_t</a> dec_settings; <span class="comment">//decoder settings</span>
    <span class="keywordtype">void</span> *enc_handle; <span class="comment">//encoder handle</span>
    <span class="keywordtype">void</span> *dec_handle; <span class="comment">//decoder handle</span>
    <span class="keywordtype">void</span> *nal_extractor; <span class="comment">//nal extractor for decoder</span>
} transcode_data_t;
<span class="comment">//functions to work with the above structure</span>

<span class="comment">// ---- Public functions ----------- </span>
<span class="comment">//open input file and creates nal extractor and decoder</span>
<span class="comment">//Called after all public members are set</span>
<span class="comment">//Return 0 - OK or error code</span>
<span class="keywordtype">int</span> sample_transcode_init(transcode_data_t *transcode_data);

<span class="comment">//run all transcoding (called after above function is called and returns OK)</span>
<span class="comment">//Note, that encoder init will be done somewhere inside this function.</span>
<span class="comment">//This is done because dimension of frames in input stream is not defined yet</span>
<span class="keywordtype">void</span> sample_transcode_run(transcode_data_t *transcode_data);

<span class="comment">//close all</span>
<span class="keywordtype">void</span> sample_transcode_close(transcode_data_t *transcode_data);


<span class="comment">// ----------------------------- Implementation -----------------------------------</span>
<span class="preprocessor">#define READ_BUF 4096</span>
<span class="preprocessor"></span><span class="preprocessor">#define INIT_NAL_SIZE 4096</span>
<span class="preprocessor"></span><span class="keyword">static</span> byte input_block[READ_BUF];

<span class="keyword">static</span> <span class="keywordtype">void</span> output_files_init(transcode_data_t *transcode_data)
{
    <a class="code" href="structv4e__settings__t.html" title="All encoder settings.">v4e_settings_t</a> *s = &amp;transcode_data-&gt;enc_settings;
    <span class="keywordtype">int</span> i, num_ms_streams;
    <span class="keywordtype">char</span> ms_draft[MAX_FILE_NAME];
    <span class="keywordtype">char</span> *dot;

    <span class="keywordflow">if</span> (transcode_data-&gt;output_file == NULL)
    {
        verbose_print(0, <span class="stringliteral">"Warning: No output file specified\n"</span>);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#b9a25fb28ebf4cce9e1d69d9f2ea52b7" title="number of svc-layers (0 means no SVC)">num_layers</a> &lt;= 0 || s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#408e8588246f8a76c37050f56695297b">multistream_mode</a> != <a class="code" href="v4e__settings_8h.html#73683698f52b7fac59e9fa6cb29699a71d5b55cd95b04c2ec8cf10bd63b59e12" title="AVC - generate several AVC streams.">MULTISTREAM_MODE_AVC</a>)
    {
        transcode_data-&gt;num_out_files = 1;
        transcode_data-&gt;files_out[0] = fopen(transcode_data-&gt;output_file, <span class="stringliteral">"wb"</span>);
        <span class="keywordflow">if</span>(transcode_data-&gt;files_out[0] == NULL)
            verbose_print(0, <span class="stringliteral">"Warning: can't open output file [%s]\n"</span>, transcode_data-&gt;output_file);
    }
    <span class="keywordflow">else</span>
    {
        transcode_data-&gt;num_out_files = num_ms_streams = s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#b9a25fb28ebf4cce9e1d69d9f2ea52b7" title="number of svc-layers (0 means no SVC)">num_layers</a> + 1;
        strcpy(ms_draft, transcode_data-&gt;output_file);
        dot = strchr(ms_draft, <span class="charliteral">'.'</span>);
        <span class="keywordflow">if</span> (dot != NULL) *dot = <span class="charliteral">'\0'</span>;
        <span class="keywordflow">for</span>(i = 0; i &lt; num_ms_streams; i++)<span class="comment">// Generate stream names and open output files</span>
        {
            <span class="keywordtype">int</span> width, height, bitrate, qp;
            <span class="keywordtype">char</span> ms_name[MAX_FILE_NAME];
            <span class="keywordtype">char</span> suffix[MAX_FILE_NAME];

            <span class="keywordflow">if</span>(i == 0)
            {   <span class="comment">// from base layer settings</span>
                width   = s-&gt;<a class="code" href="structv4e__settings__t.html#4e97b24b422ee624a81c698c25c9dcd3" title="encoding frame width, pixels; [will be automatically calculated by &amp;quot;check_settings()&amp;quot;]...">frame_width</a>;
                height  = s-&gt;<a class="code" href="structv4e__settings__t.html#c64066f22394a290707a0b326779ee57" title="encoding frame height, pixels; [will be automatically calculated by &amp;quot;check_settings()&amp;quot;]...">frame_height</a>;
                bitrate = s-&gt;<a class="code" href="structv4e__settings__t.html#673f06b50e9489afa73087ee5baeb146" title="Rate Control settings;.">rc</a>.<a class="code" href="structrate__control__settings__t.html#667f38da2f2c7f41c9584b1534d1d3d1" title="desired bitrate (kbits per sec);">kbps</a>;
                qp      = s-&gt;<a class="code" href="structv4e__settings__t.html#673f06b50e9489afa73087ee5baeb146" title="Rate Control settings;.">rc</a>.<a class="code" href="structrate__control__settings__t.html#e017f816dcf1784e2126ebf92b847c2f" title="init param for intra frames (0..51);">qp_intra</a>;
            }
            <span class="keywordflow">else</span>
            {   <span class="comment">// from svc layers settings</span>
                width   = s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#fc8f65b519af39d1a8548884b49ed5a3" title="Last valid element of this array is related to the to the most “rich” layer.">layer</a>[i-1].<a class="code" href="structsvc__layer__settings__t.html#7783c8bf3d8098aa2700d551890281ac" title="encoding frame width, pixels;">frame_width</a>;
                height  = s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#fc8f65b519af39d1a8548884b49ed5a3" title="Last valid element of this array is related to the to the most “rich” layer.">layer</a>[i-1].<a class="code" href="structsvc__layer__settings__t.html#c67c8334afbf131d5cb5471814903bc5" title="encoding frame height, pixels;">frame_height</a>;
                bitrate = s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#fc8f65b519af39d1a8548884b49ed5a3" title="Last valid element of this array is related to the to the most “rich” layer.">layer</a>[i-1].<a class="code" href="structsvc__layer__settings__t.html#a730738dd24fa4d7a0267c1620519166" title="desired bitrate (for this plus below levels) Must be greater then kbps for previous...">kbps</a>;
                qp      = s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#fc8f65b519af39d1a8548884b49ed5a3" title="Last valid element of this array is related to the to the most “rich” layer.">layer</a>[i-1].<a class="code" href="structsvc__layer__settings__t.html#27bd2061ea4766a0e4f6d6128d93051a" title="qp for intra-frames coding (qp_delta_p and qp_delta_b is used from main settings)(used...">qp_intra</a>;
            }

            <span class="keywordflow">if</span>(s-&gt;<a class="code" href="structv4e__settings__t.html#0eb9ab59c4fc040a3d4710b5ccfe617d" title="svc encoding settings">svc</a>.<a class="code" href="structsvc__settings__t.html#408e8588246f8a76c37050f56695297b">multistream_mode</a> == <a class="code" href="v4e__settings_8h.html#73683698f52b7fac59e9fa6cb29699a707978eefce87eb9a860050a53491ff58" title="MVC - generate MVC stream.">MULTISTREAM_MODE_MVC</a>)
                sprintf(suffix, <span class="stringliteral">"%d.264"</span>, i);
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">if</span>(s-&gt;<a class="code" href="structv4e__settings__t.html#673f06b50e9489afa73087ee5baeb146" title="Rate Control settings;.">rc</a>.<a class="code" href="structrate__control__settings__t.html#6035018e99cb75d477cd5d75291d69d8" title="rate control mode;">type</a> != <a class="code" href="v4e__settings_8h.html#ba66a1cb381789f7785de43b8b66c3bc00321cae4ed1af0817cb6710e7eb3251" title="fixed quality (fixed QP);">RATE_CONTROL_QP</a>)
                    sprintf(suffix, <span class="stringliteral">"%d_%dx%d_%dkbps.264"</span>, i+1, width, height, bitrate);
                <span class="keywordflow">else</span>
                    sprintf(suffix, <span class="stringliteral">"%d_%dx%d_qp%d.264"</span>, i+1, width, height, qp);
            }
            strcpy(ms_name, ms_draft);
            strncat(ms_name, suffix, <span class="keyword">sizeof</span>(suffix));
            transcode_data-&gt;files_out[i] = fopen(ms_name, <span class="stringliteral">"wb"</span>);
            <span class="keywordflow">if</span>(transcode_data-&gt;files_out[i] == NULL)
                verbose_print(0, <span class="stringliteral">"Warning: can't open multi-stream file [%s]\n"</span>, ms_name);
        }
    }
}


<span class="keyword">static</span> <span class="keywordtype">void</span> output_files_close(transcode_data_t *transcode_data)
{
    <span class="keywordtype">int</span> i;

    <span class="keywordflow">for</span>(i = 0; i &lt; transcode_data-&gt;num_out_files; i++)
    {
        <span class="keywordflow">if</span>(transcode_data-&gt;files_out[i] != NULL)
            fclose(transcode_data-&gt;files_out[i]);
        transcode_data-&gt;files_out[i] = NULL;
    }
}


<span class="keyword">static</span> <span class="keywordtype">void</span> prepare_dec_settings(transcode_data_t *transcode_data)
{
    <a class="code" href="structv4d__settings__t.html">v4d_settings_t</a> *dec_settings = &amp;transcode_data-&gt;dec_settings;
    <a class="code" href="group__dec__func.html#gbe73f179f088c7cd068e1054ef5509f8" title="Set default decoder settings.">v4d_default_settings</a>(dec_settings, transcode_data-&gt;mt_dec == 0);
    <span class="keywordflow">if</span> (transcode_data-&gt;mt_dec &gt; 0)
        dec_settings-&gt;<a class="code" href="structv4d__settings__t.html#2273d6203e6dddc14d10ad3c2fa7c67d">mt_settings</a>.<a class="code" href="structmt__dec__settings__t.html#edd3e4343e03a95ee7faface802b542b">num_threads</a> = transcode_data-&gt;mt_dec;
}

<span class="keywordtype">int</span> sample_transcode_init(transcode_data_t *transcode_data)
{
    <span class="keywordtype">int</span> rc;
    prepare_dec_settings(transcode_data);
    <span class="comment">// create NAL parser</span>
    <span class="keywordflow">if</span> (transcode_data-&gt;input_file == NULL)
    {
        verbose_print(0,<span class="stringliteral">"Error: No input file specified\n"</span>);
        transcode_data-&gt;status = -1;
        <span class="keywordflow">return</span> -1;
    }

    transcode_data-&gt;file_in = fopen(transcode_data-&gt;input_file, <span class="stringliteral">"rb"</span>);

    <span class="keywordflow">if</span> (transcode_data-&gt;orig_file != NULL) 
        transcode_data-&gt;orig_in = fopen(transcode_data-&gt;orig_file, <span class="stringliteral">"rb"</span>);


    <span class="keywordflow">if</span> (transcode_data-&gt;file_in == NULL)
    {
        verbose_print(0,<span class="stringliteral">" Error: Can't open file: %s\n"</span>, transcode_data-&gt;input_file);
        transcode_data-&gt;status = -1;
        <span class="keywordflow">return</span> -1;
    }

    output_files_init(transcode_data); <span class="comment">//not required</span>

    transcode_data-&gt;nal_extractor = <a class="code" href="group__dec__func.html#g9a18a41bbfa5fc81549b77a4b36584a5" title="Init input stream buffer.">v4d_nal_extractor_create_ex</a>(INIT_NAL_SIZE, 0);
    <span class="keywordflow">if</span> (transcode_data-&gt;nal_extractor == NULL)
    {
        verbose_print(0,<span class="stringliteral">"Error: v4d_nal_extractor_create() returned NULL\n"</span>);
        transcode_data-&gt;status = -1;
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">// create decoder instance</span>
    rc = <a class="code" href="group__dec__func.html#g80a3db11fb6b7faa45f35b2e6a7ff89f" title="Create a new decoder instance.">v4d_open</a>(&amp;transcode_data-&gt;dec_handle, &amp;transcode_data-&gt;dec_settings);
    <span class="keywordflow">if</span> (rc != <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>)
    {
        verbose_print(0,<span class="stringliteral">"Error: v4d_open() failed (%d): %s\n"</span>, rc, <a class="code" href="v4__types_8h.html#02e6cdb9da96a1559dfe16f35656d4a6">v4_error_text</a>(rc));
        transcode_data-&gt;status = -2;
        <span class="keywordflow">return</span> -2;
    }

    <span class="keywordflow">return</span> 0;
}

<span class="comment">//this function is called for each encoded NAL</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> receive_nal_callback(<span class="keywordtype">void</span> *context, <a class="code" href="structmedia__sample__t.html">media_sample_t</a> *ms)
{
    transcode_data_t *transcode_data = context;
    <span class="keywordflow">if</span> (ms)
    {
        <span class="keyword">static</span> byte start_code[4] = {0,0,0,1};
        <a class="code" href="structframe__info__t.html" title="Generic frame information.">frame_info_t</a> *frame_info = (<a class="code" href="structframe__info__t.html" title="Generic frame information.">frame_info_t</a> *)(&amp;ms-&gt;<a class="code" href="structmedia__sample__t.html#5bc638fb7b2c7d04af4212143dc77d97" title="can be used for support information">extra_data</a>);
        <span class="keywordtype">int</span> n = 0;

        <span class="keywordflow">if</span> (transcode_data-&gt;num_out_files &gt; 1) n = frame_info-&gt;<a class="code" href="structframe__info__t.html#b7fb286f52675fa9b18531911aff4d7e" title="stream number in multi-stream mode (0 ... MAX_AVC_STREAMS-1)">num_stream</a>;

        <span class="keywordflow">if</span> (n &lt; transcode_data-&gt;num_out_files &amp;&amp; transcode_data-&gt;files_out[n] != NULL)
        {
            fwrite(start_code, 1, 4, transcode_data-&gt;files_out[n]);
            fwrite(ms-&gt;<a class="code" href="structmedia__sample__t.html#fc893318b1f2b8f9412090e104d33f9e" title="data buffer">data</a>, 1, ms-&gt;<a class="code" href="structmedia__sample__t.html#aeaf60c3f4396ad4b4d24f1ffe62eca5" title="total used size, bytes">used_size</a>, transcode_data-&gt;files_out[n]);
        }
        <a class="code" href="v4__media__sample_8h.html#b9ff1ee2911ee3fd4fdb6dd497a91e0f" title="Free previously allocated media sample;.">v4_free_media_sample</a>(ms);
    }
    <span class="keywordflow">return</span> 0;
}


<span class="keyword">static</span> <span class="keywordtype">void</span> init_encoder(transcode_data_t *transcode_data, <a class="code" href="structyuv__frame__t.html" title="YUV pixel domain image arrays for uncompressed video frame.">yuv_frame_t</a> *dec_frame)
{
    <a class="code" href="structv4__receive__nal__t.html">v4_receive_nal_t</a>    nal_receive;
    <span class="keywordtype">int</span> rc;
    <span class="comment">//TODO replace check below by proper update of preproc settings</span>
    <span class="keywordflow">if</span> (dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a> != transcode_data-&gt;enc_settings.input.width || dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a> != transcode_data-&gt;enc_settings.input.height)
    {
        <span class="comment">//add resize step</span>
        <span class="keywordtype">int</span> i;
        <span class="keywordflow">if</span> (dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a> &lt; transcode_data-&gt;enc_settings.input.width || dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a> &lt; transcode_data-&gt;enc_settings.input.height)
        {
            verbose_print(0, <span class="stringliteral">"Error: Upscaling is not allowed\n"</span>);
            transcode_data-&gt;status = -1;
            <span class="keywordflow">return</span>;
        }
        assert(transcode_data-&gt;enc_settings.preproc.step[6].type == <a class="code" href="v4e__preproc__settings_8h.html#19405d78ecffba7d431541ced42fd300cb5ec123e88fa0c9a1548d1f05b03e0f">S_NONE</a>);
        <span class="keywordflow">for</span> (i = 6; i &gt; 0; i--)
            transcode_data-&gt;enc_settings.preproc.step[i] = transcode_data-&gt;enc_settings.preproc.step[i-1];
        transcode_data-&gt;enc_settings.preproc.step[0].type = <a class="code" href="v4e__preproc__settings_8h.html#19405d78ecffba7d431541ced42fd300f33118f5fff8a9038bda49d7b5f027da">RESIZE</a>;
        transcode_data-&gt;enc_settings.preproc.step[0].param0 = transcode_data-&gt;enc_settings.input.width;
        transcode_data-&gt;enc_settings.preproc.step[0].param1 = transcode_data-&gt;enc_settings.input.height;
        transcode_data-&gt;enc_settings.input.width = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>;
        transcode_data-&gt;enc_settings.input.height = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a>;
    }
    nal_receive.<a class="code" href="structv4__receive__nal__t.html#50df277901daeba951e8be285c1c7aff" title="application context for receive nal callback;">context</a> = transcode_data;
    nal_receive.<a class="code" href="structv4__receive__nal__t.html#faae804787edfae1ee00167968182b60" title="receive nal callback function;">callback</a> = receive_nal_callback;
    rc = <a class="code" href="group__enc__func.html#g1e1356adaa4568c35ee17aeb4e9e7c50" title="Extended version of v4e_open() Create a new encoder instance.">v4e_open_ex</a>(&amp;transcode_data-&gt;enc_handle, &amp;transcode_data-&gt;enc_settings, NULL, &amp;nal_receive);
    <span class="keywordflow">if</span> (rc &gt; <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>)
    {
        verbose_print(0, <span class="stringliteral">"Warning: v4e_open_ex(): %d [%s]\n"</span>, rc, <a class="code" href="v4__types_8h.html#02e6cdb9da96a1559dfe16f35656d4a6">v4_error_text</a>(rc));
    }
    <span class="keywordflow">if</span> (rc &lt; <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>)
    {
        verbose_print(0, <span class="stringliteral">"Error: v4e_open_ex(): %d [%s]\n"</span>, rc, <a class="code" href="v4__types_8h.html#02e6cdb9da96a1559dfe16f35656d4a6">v4_error_text</a>(rc));
        transcode_data-&gt;status = rc;
        <span class="keywordflow">return</span>;
    }
}

<span class="keyword">static</span> <span class="keywordtype">void</span> pass_yuv_to_encoder(transcode_data_t *transcode_data, <a class="code" href="structyuv__frame__t.html" title="YUV pixel domain image arrays for uncompressed video frame.">yuv_frame_t</a> *dec_frame)
{
    <span class="keywordflow">if</span> (transcode_data-&gt;status == 0 &amp;&amp; transcode_data-&gt;enc_handle == NULL &amp;&amp; dec_frame)
    {
        init_encoder(transcode_data, dec_frame);
        <span class="keywordflow">if</span> (transcode_data-&gt;status != 0)
            verbose_print(0,<span class="stringliteral">"Error: init_encoder() failed (%d): %s\n"</span>, transcode_data-&gt;status, <a class="code" href="v4__types_8h.html#02e6cdb9da96a1559dfe16f35656d4a6">v4_error_text</a>(transcode_data-&gt;status));
        <span class="keywordflow">if</span> (transcode_data-&gt;orig_in) <span class="comment">//we will substitude decoded pixels by original pixels. Alloc buffer to read original pixels</span>
        {
            transcode_data-&gt;orig_pixels_size = 3*dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a>*dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>/2; <span class="comment">//TODO 10-bit and 422</span>
            transcode_data-&gt;orig_pixels = malloc(transcode_data-&gt;orig_pixels_size);
        }

    }
    <span class="keywordflow">if</span> (transcode_data-&gt;status != 0)
        <span class="keywordflow">return</span>;

    <span class="keywordflow">if</span> (dec_frame)
    {
        <a class="code" href="structvp__raw__frame__t.html" title="structure holding external image and it&amp;#39;s characteristics">vp_raw_frame_t</a> vp_raw_frame;
        <a class="code" href="structmedia__sample__t.html">media_sample_t</a> *mbs_data = NULL;
        assert(dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a> == transcode_data-&gt;enc_settings.input.width);
        assert(dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a> == transcode_data-&gt;enc_settings.input.height);
        memset(&amp;vp_raw_frame, 0, <span class="keyword">sizeof</span>(<a class="code" href="structvp__raw__frame__t.html" title="structure holding external image and it&amp;#39;s characteristics">vp_raw_frame_t</a>));
        vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#bedfc2e877b92f8beacd2336fe3c9614" title="number of bits per luma value (8..14);">luma_bits</a> = 8; <span class="comment">//This is not needed. TODO remove when VPL will be fixed</span>
        <span class="keywordflow">if</span> (transcode_data-&gt;orig_pixels != NULL) <span class="comment">//read original pixels to pass to transcoder</span>
        {
            <span class="keywordtype">int</span> size = (int)fread(transcode_data-&gt;orig_pixels, 1, transcode_data-&gt;orig_pixels_size, transcode_data-&gt;orig_in);
            <span class="keywordflow">if</span> (size &gt; 0)
            {
                vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#346473e10e77652b7f12226940cd24db">data</a>[0] = transcode_data-&gt;orig_pixels;
                vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#346473e10e77652b7f12226940cd24db">data</a>[1] = transcode_data-&gt;orig_pixels + dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a>*dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>;
                vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#346473e10e77652b7f12226940cd24db">data</a>[2] = transcode_data-&gt;orig_pixels + 5*dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#23664d91ad80a393ff5caa0ec47c7d4b" title="actual image height in pixels, less or equal to buffer height;">image_height</a>*dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>/4;
                vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#6ff3a2037683d279c1702c4eebfbf107">stride</a>[0] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>;
                vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#6ff3a2037683d279c1702c4eebfbf107">stride</a>[1] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>/2;
                vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#6ff3a2037683d279c1702c4eebfbf107">stride</a>[2] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#d96501af9039ccaf609e0d9826b3d16b" title="actual image width in pixels, less or equal to buffer width;">image_width</a>/2;
            }
            <span class="keywordflow">else</span> <span class="comment">//nothing to read from file. Finish with it</span>
            {
                free(transcode_data-&gt;orig_pixels);
                transcode_data-&gt;orig_pixels = NULL;
            }
        }
        <span class="keywordflow">if</span> (transcode_data-&gt;orig_pixels == NULL) <span class="comment">//pass decoded pixels</span>
        {
            vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#346473e10e77652b7f12226940cd24db">data</a>[0] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#0dc9e83f53ed907afddebf0ab1613047" title="pointer to Y component data">y</a>;
            vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#346473e10e77652b7f12226940cd24db">data</a>[1] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#f14eb4f7f0fa21266e4cc1cdb295c22b" title="pointer to U component data">u</a>;
            vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#346473e10e77652b7f12226940cd24db">data</a>[2] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#a39935b71d3fad626e3f699604615a38" title="pointer to V component data">v</a>;
            vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#6ff3a2037683d279c1702c4eebfbf107">stride</a>[0] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#221676b64bf172f5bc344c0c177b86f6" title="stride of luma lines allocation in pixels!!!">stride_y</a>;
            vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#6ff3a2037683d279c1702c4eebfbf107">stride</a>[1] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#526ea0e5d8a975c41acfd9ae6ba47187" title="stride of chroma lines allocation in pixels!!!">stride_uv</a>;
            vp_raw_frame.<a class="code" href="structvp__raw__frame__t.html#6339617e112e0939b8ad06e361e942cd">vp_frame</a>.<a class="code" href="structvp__frame__t.html#6ff3a2037683d279c1702c4eebfbf107">stride</a>[2] = dec_frame-&gt;<a class="code" href="structyuv__frame__t.html#526ea0e5d8a975c41acfd9ae6ba47187" title="stride of chroma lines allocation in pixels!!!">stride_uv</a>;
        }
        <span class="comment">//TODO timstamps and other</span>
        <span class="keywordflow">if</span> (transcode_data-&gt;transcode)
            <a class="code" href="group__dec__func.html#g8037b2427d03d7a889785548764ece46" title="Get frame macroblocks data.">v4d_get_frame_macroblocks_data</a>(transcode_data-&gt;dec_handle, dec_frame, &amp;mbs_data);
        <a class="code" href="group__enc__func.html#gbde1214d5fc2ff9a9e3372395410eb79" title="The function sends given frame and its macrobock data to encoder.">v4e_set_vp_frame_and_mbs_data</a>(transcode_data-&gt;enc_handle, &amp;vp_raw_frame, mbs_data, 1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transcode_data-&gt;enc_handle)
        <a class="code" href="group__enc__func.html#g5d17bfa8acdf3f8419d94560a351daf3" title="This function signals encoder to process all the pending frames and return all NAL...">v4e_set_flush</a>(transcode_data-&gt;enc_handle);
}


<span class="keywordtype">void</span> sample_transcode_run(transcode_data_t *transcode_data)
{
    <a class="code" href="structmedia__sample__t.html">media_sample_t</a> *ms;
    <a class="code" href="structyuv__frame__t.html" title="YUV pixel domain image arrays for uncompressed video frame.">yuv_frame_t</a> *dec_frame;
    <a class="code" href="v4timer_8h.html#a27b207a9c07e9d06d68c998a758f708">timer_clock_t</a> start_time;
    <a class="code" href="v4timer_8h.html#dfcc0da44bfb44713477a0115d2bef76">timer_delta_t</a> delta_time;
    <span class="keywordtype">int</span> total_frames_read, total_frames_coded, total_ms, end_of_stream, end_of_ms;
    int64_t ts, dts;

    <a class="code" href="v4timer_8h.html#7b8ab79df77b57475a5494f5f81c3bd9">timer_init</a>();
    timer_start(&amp;start_time);

    ts = 0;
    dts = 1;
    total_frames_read = total_frames_coded = 0;
    <span class="keywordflow">for</span> (end_of_stream = 0; !end_of_stream &amp;&amp; transcode_data-&gt;status == 0; )
    {
        <span class="keywordtype">int</span> read_size = (int)fread(input_block, 1, READ_BUF, transcode_data-&gt;file_in);
        <span class="keywordflow">if</span> (read_size &lt;= 0) <span class="comment">// end of file</span>
        {
            <span class="comment">// inform parser about end of stream to allow the last NAL unit be treated as completed</span>
            <a class="code" href="group__dec__func.html#g5183bf0f664750fd230af6672ed159f9" title="Put RBSP bytes into stream buffer.">v4d_nal_extractor_feed_data</a>(transcode_data-&gt;nal_extractor, NULL, 0,  0, <a class="code" href="v4__types_8h.html#34bd22709dbe71aa0ea953cb4884a8a0" title="This means that timestamp is not passed.">NO_TIME_STAMP</a>);
            end_of_stream = 1;
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">// feed next portion of H.264 stream into input parser</span>
            <a class="code" href="group__dec__func.html#g5183bf0f664750fd230af6672ed159f9" title="Put RBSP bytes into stream buffer.">v4d_nal_extractor_feed_data</a>(transcode_data-&gt;nal_extractor, input_block, read_size,  0, ts);
            ts += dts;
        }
        <span class="keywordflow">for</span> (end_of_ms=0; !end_of_ms; )
        {
            <span class="comment">// extract next NAL unit from parser</span>
            ms = <a class="code" href="group__dec__func.html#g358f1867dbf318050228795349516520" title="Extract next NAL unit from the buffer (or NULL if nothing available) This nal unit...">v4d_nal_extractor_get_nalu</a>(transcode_data-&gt;nal_extractor);
            <span class="keywordflow">if</span> (ms)
                <a class="code" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit</a>(transcode_data-&gt;dec_handle, ms);
            <span class="keywordflow">else</span> 
            {
                end_of_ms = 1;
                <span class="keywordflow">if</span> (end_of_stream) <span class="comment">// tell decoder that it is the last NAL unit</span>
                    <a class="code" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit</a>(transcode_data-&gt;dec_handle, NULL);
            }
            <span class="comment">// now try to receive all decoded YUV frames</span>
            <span class="keywordflow">while</span> (<a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a> == <a class="code" href="group__dec__func.html#g7beedf7d273a4a174589fc6245cc7e99" title="Try to take next decoded frame.">v4d_get_frame</a>(transcode_data-&gt;dec_handle, &amp;dec_frame, NULL))
            {
                verbose_print(0, <span class="stringliteral">"Frames: Read:%10d    Coded:%10d         \r"</span>, total_frames_read, total_frames_coded);
                total_frames_read++;
                <span class="keywordflow">if</span> (total_frames_read &gt;= transcode_data-&gt;frame_start)
                {
                    pass_yuv_to_encoder(transcode_data, dec_frame);
                    total_frames_coded++;
                }
                <span class="keywordflow">if</span> (total_frames_coded == transcode_data-&gt;max_frames)
                {
                    end_of_ms = end_of_stream = 1;
                    <span class="keywordflow">break</span>;
                }
            }
        }
    }
    pass_yuv_to_encoder(transcode_data, NULL);

    delta_time = timer_delta(&amp;start_time);
    total_ms = timer_delta_ms(delta_time);

    verbose_print(0, <span class="stringliteral">"%20s: %d\n"</span>, <span class="stringliteral">"total frames"</span>, total_frames_coded);
    verbose_print(0, <span class="stringliteral">"%20s: %d\n"</span>, <span class="stringliteral">"total time, ms"</span>, total_ms);
    <span class="keywordflow">if</span> (total_ms &gt; 0)
        verbose_print(0, <span class="stringliteral">"%20s: %d\n"</span>, <span class="stringliteral">"total speed, fps"</span>, (total_frames_coded*1000 + total_ms/2)/total_ms);
}

<span class="keywordtype">void</span> sample_transcode_close(transcode_data_t *transcode_data)
{
    output_files_close(transcode_data);
    <span class="keywordflow">if</span> (transcode_data-&gt;file_in) fclose(transcode_data-&gt;file_in);
    <span class="keywordflow">if</span> (transcode_data-&gt;orig_in) fclose(transcode_data-&gt;orig_in);
    <span class="keywordflow">if</span> (transcode_data-&gt;dec_handle) <a class="code" href="group__dec__func.html#ga61ae04d7e83f191fd2a03d7186f96ec" title="Close decoder, release memory etc.">v4d_close</a>(transcode_data-&gt;dec_handle);
    <span class="keywordflow">if</span> (transcode_data-&gt;enc_handle) <a class="code" href="group__enc__func.html#g614215be21ac702d8bbd1a28c6621421" title="This function will impose flush event if not yet flushed to release output thread...">v4e_close</a>(transcode_data-&gt;enc_handle);
    <span class="keywordflow">if</span> (transcode_data-&gt;nal_extractor) <a class="code" href="group__dec__func.html#gbc0d7fbc4737482910f47a59a630ba16" title="Release stream buffer.">v4d_nal_extractor_close</a>(transcode_data-&gt;nal_extractor);
}

<span class="comment">// --------------- end of transcode module implementation -------------------</span>



<span class="comment">// ------------- main function stuff ---------------- </span>

<span class="keyword">static</span> transcode_data_t g_transcode_data = {0}; <span class="comment">//static structure</span>



<span class="comment">// map input parameters to command line options  </span>
<span class="keyword">static</span> <a class="code" href="structcmd__arg__t.html">cmd_arg_t</a> all_args[] =
{
    { <span class="stringliteral">"i"</span>, <span class="stringliteral">"yf"</span>, <span class="stringliteral">"input-file"</span>,   1, &amp;g_transcode_data.input_file,  0, <span class="stringliteral">"name of input H.264 file"</span> },
    { <span class="stringliteral">"o"</span>, <span class="stringliteral">"hf"</span>, <span class="stringliteral">"output-file"</span>,  1, &amp;g_transcode_data.output_file, 0, <span class="stringliteral">"name of output H.264 file"</span> },
    { <span class="stringliteral">"-"</span>, <span class="stringliteral">"of"</span>, <span class="stringliteral">"orig-file"</span>,    1, &amp;g_transcode_data.orig_file,   0, <span class="stringliteral">"name of input original yuv file"</span> },
    { <span class="stringliteral">"c"</span>, <span class="stringliteral">"cf"</span>, <span class="stringliteral">"config-file"</span>,  1, &amp;g_transcode_data.config_file, 0, <span class="stringliteral">"name of encoder config file"</span> },
    { <span class="stringliteral">"w"</span>, <span class="stringliteral">"fw"</span>, <span class="stringliteral">"frame-width"</span>,  0, &amp;g_transcode_data.frame_width, 0, <span class="stringliteral">"input frame width, pixels (divisible by 2)"</span> },
    { <span class="stringliteral">"h"</span>, <span class="stringliteral">"fh"</span>, <span class="stringliteral">"frame-height"</span>, 0, &amp;g_transcode_data.frame_height,0, <span class="stringliteral">"input frame height, pixels (divisible by 2)"</span> },
    { <span class="stringliteral">"n"</span>, <span class="stringliteral">"fn"</span>, <span class="stringliteral">"frame-count"</span>,  0, &amp;g_transcode_data.max_frames,  0, <span class="stringliteral">"max number of input frames to process"</span> },
    { <span class="stringliteral">"s"</span>, <span class="stringliteral">"fs"</span>, <span class="stringliteral">"frame-start"</span>,  0, &amp;g_transcode_data.frame_start, 0, <span class="stringliteral">"frame to start encoding"</span> },
    { <span class="stringliteral">"v"</span>, <span class="stringliteral">"vb"</span>, <span class="stringliteral">"verbose"</span>,      0, &amp;g_transcode_data.verbose,     1, <span class="stringliteral">"level of verbose messages (0/1/2)"</span> },
    { <span class="stringliteral">"m"</span>, <span class="stringliteral">"mt"</span>, <span class="stringliteral">"threads"</span>,      0, &amp;g_transcode_data.mt_dec,     -1, <span class="stringliteral">"number of threads in decoder(-1=auto, 0=disable)"</span> },
    { <span class="stringliteral">"t"</span>, <span class="stringliteral">"tm"</span>, <span class="stringliteral">"transcode"</span>,    0, &amp;g_transcode_data.transcode,   1, <span class="stringliteral">"transcode mode (0 - simple recode; 1-transcode)"</span> },
};

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> all_args_cnt = <span class="keyword">sizeof</span>(all_args)/<span class="keyword">sizeof</span>(all_args[0]);


<span class="keyword">static</span> <span class="keywordtype">void</span> usage(<span class="keywordtype">void</span>)
{
    verbose_print(0, <span class="stringliteral">"USAGE:\n"</span>);
    verbose_print(0, <span class="stringliteral">"\t &gt; sample_enc [-option value] [param=value]\n"</span>);
    verbose_print(0, <span class="stringliteral">"WHERE:\n"</span>);
}


<span class="keyword">static</span> <span class="keywordtype">int</span> dump_nondef_params(<span class="keywordtype">void</span> *ctx, <span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *fmt, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> def)
{
    <span class="keywordtype">char</span> sformat[256];
    <span class="keywordflow">if</span> (value != def)
    {
        sprintf(sformat, <span class="stringliteral">"%%s = %s\n"</span>, fmt);
        verbose_print(1, sformat, name, value);
    }
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> <span class="keywordtype">int</span> dump_all_params(<span class="keywordtype">void</span> *ctx, <span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *fmt, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> def)
{
    <span class="keywordtype">char</span> sformat[256];
    sprintf(sformat, <span class="stringliteral">"%%s = %s\n"</span>, fmt);
    verbose_print(1, sformat, name, value);
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> <span class="keywordtype">void</span> dump_encoder_settings(<a class="code" href="structv4e__settings__t.html" title="All encoder settings.">v4e_settings_t</a> *settings, <span class="keywordtype">int</span> verbose)
{
    <span class="comment">// use callback function to dump encoder settings to standard output</span>
    <span class="keywordflow">switch</span> (verbose)
    {
    <span class="keywordflow">case</span> 1:
        <a class="code" href="group__enc__func.html#gcf1c698170ae036dc0b9e7805212e64e" title="Dump given encoder settings via callback function.">v4e_settings2buf_ex</a>(settings, NULL, dump_nondef_params);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2:
        <a class="code" href="group__enc__func.html#gcf1c698170ae036dc0b9e7805212e64e" title="Dump given encoder settings via callback function.">v4e_settings2buf_ex</a>(settings, NULL, dump_all_params);
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">return</span>;
    }
    verbose_print(1, <span class="stringliteral">"\n"</span>);
}


<span class="keywordtype">int</span> prepare_enc_settings(transcode_data_t *transcode_data, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <a class="code" href="structv4e__settings__t.html" title="All encoder settings.">v4e_settings_t</a> *settings = &amp;transcode_data-&gt;enc_settings; 
    <span class="keywordtype">int</span> i, rc;
    <span class="comment">// in order to avoid collisions application has to specify size of settings structure</span>
    settings-&gt;<a class="code" href="structv4e__settings__t.html#befb939f42d1b2d5b76358ce61586bdd" title="put a size of your structure here - to prevent problems with version compatibility...">size</a> = <span class="keyword">sizeof</span>(<a class="code" href="structv4e__settings__t.html" title="All encoder settings.">v4e_settings_t</a>);
    rc = <a class="code" href="group__enc__func.html#g697e01cb802f6b569ff8774a530fc1ab" title="Provide default encoder settings into given structure.">v4e_default_settings</a>(settings);
    <span class="keywordflow">if</span> (rc != <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>)
    {
        <span class="keywordflow">if</span> (rc == <a class="code" href="group__return__codes.html#g30808e48eec74719610a650cdb393290" title="Error: wrong function argument value.">VSSH_ERR_ARG</a>)
            verbose_print(0, <span class="stringliteral">"Error: invalid version of encoder settings linked in (%d)\n"</span>, rc);
        <span class="keywordflow">else</span>
            verbose_print(0, <span class="stringliteral">"Error: v4e_default_settings() failed (%d)\n"</span>, rc);
        <span class="keywordflow">return</span> rc;
    }

    <span class="comment">// read encoder config file</span>
    <span class="keywordflow">if</span> (transcode_data-&gt;config_file)
    {
        rc = <a class="code" href="group__enc__func.html#g90295a40bf61908245fe520674a38949" title="Load given configuration text file.">v4e_read_config_file</a>(settings, transcode_data-&gt;config_file);
        <span class="keywordflow">if</span> (rc != <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>)
        {
            verbose_print(0, <span class="stringliteral">"Error: can't open config file [%s]\n"</span>, transcode_data-&gt;config_file);
            <span class="keywordflow">return</span> rc;
        }
    }

    <span class="comment">// command line arguments override encoder settings:</span>
    <span class="keywordflow">if</span> (transcode_data-&gt;frame_width &gt; 0)
        settings-&gt;<a class="code" href="structv4e__settings__t.html#d5e9ef1ce39f150fadd44e7cfa95e14f" title="input picture description;">input</a>.<a class="code" href="structinput__picture__t.html#350e9e105180c1c48f533bd331558189" title="picture width, pixels">width</a>  = transcode_data-&gt;frame_width;
    <span class="keywordflow">if</span> (transcode_data-&gt;frame_height &gt; 0)
        settings-&gt;<a class="code" href="structv4e__settings__t.html#d5e9ef1ce39f150fadd44e7cfa95e14f" title="input picture description;">input</a>.<a class="code" href="structinput__picture__t.html#48eeb84242667de595027a4ab51725a1" title="picture height, pixels">height</a> = transcode_data-&gt;frame_height;

    <span class="comment">// now scan all command line arguments for a pairs like "name=value"</span>
    <span class="comment">// and try to apply them to encoder settings structure</span>
    <span class="keywordflow">for</span> (i=1; i&lt;argc; i++)
    {
        <span class="keywordtype">char</span> *param = argv[i];
        <span class="keywordflow">if</span> (strchr(param, <span class="charliteral">'='</span>))
        {
            <span class="keywordtype">int</span> len = (int)strlen(param);
            <span class="keywordtype">int</span> rc = <a class="code" href="group__enc__func.html#g9416903397e58cf2fb728d78d167c121" title="Parse given character string buffer into encoder settings.">v4e_buf2settings</a>(settings, param, len);
            <span class="keywordflow">if</span> (rc == <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>)
            {
                verbose_print(1, <span class="stringliteral">"*** override [%s]\n"</span>, param);
            }
        }
    }
    <span class="keywordflow">return</span> 0;
}
<span class="comment">/*</span>
<span class="comment">This program demonstrates trancoding from input H.264 file</span>
<span class="comment">*/</span>


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordtype">int</span> rc;
    <a class="code" href="structarg__ctx__t.html">arg_ctx_t</a> arg_ctx;

<span class="preprocessor">#ifdef _CRT_DEBUG_</span>
<span class="preprocessor"></span>    _CrtMemState _ms1, _ms2, _ms3;
    _CrtMemCheckpoint(&amp;_ms1);
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_CHECK_ALWAYS_DF|_CRTDBG_LEAK_CHECK_DF);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">// print codec library version</span>
    verbose_print(0, <span class="stringliteral">"sample transcoder application\n"</span>);
    print_codec_info();

    <span class="comment">// process command line arguments</span>
    arg_ctx.<a class="code" href="structarg__ctx__t.html#6cb222d46e62fdba8f25044dc8fda97d">args</a> = all_args;
    arg_ctx.<a class="code" href="structarg__ctx__t.html#3ceca726f956a04bf2cda26a4cd9a3b6">cnt</a>  = all_args_cnt;
    <span class="keywordflow">if</span> (argc &lt; 2)
    {
        usage();
        print_args(&amp;arg_ctx);
        <span class="keywordflow">return</span> 0;
    }

    read_args(&amp;arg_ctx, argc, argv);
    <span class="keywordflow">if</span> (verbose) dump_args(&amp;arg_ctx);


    rc = prepare_enc_settings(&amp;g_transcode_data, argc, argv);
    <span class="keywordflow">if</span> (rc != 0) <span class="keywordflow">return</span> -1;

    rc = <a class="code" href="v4e__api_8h.html#6e881d1ee4564cc0a9d94942e4775e15" title="This function checks input encoder settings to be valid invalid values are been corrected...">v4e_check_settings</a>(&amp;g_transcode_data.enc_settings);
    <span class="keywordflow">if</span> (rc &lt; <a class="code" href="group__return__codes.html#gb9dfadfbdfd9326b6a3b31988cd73957" title="Everything is OK.">VSSH_OK</a>) 
    {
        verbose_print(0, <span class="stringliteral">"Error: from check_settings(%d)\n"</span>, rc);
        <span class="keywordflow">return</span> -1;
    }
    <span class="keywordflow">if</span> (g_transcode_data.enc_settings.preproc.crop.enable)
    {
        verbose_print(0, <span class="stringliteral">"Warning: Disable transcoding mode for cropped image\n"</span>);
        g_transcode_data.transcode = 0;
    }

    <span class="keywordflow">if</span> (g_transcode_data.enc_settings.svc.num_layers &gt; 0)
    {
        <span class="keywordflow">if</span> (g_transcode_data.enc_settings.svc.multistream_mode == <a class="code" href="v4e__settings_8h.html#73683698f52b7fac59e9fa6cb29699a707978eefce87eb9a860050a53491ff58" title="MVC - generate MVC stream.">MULTISTREAM_MODE_MVC</a>) 
        {
            verbose_print(0, <span class="stringliteral">"Error: don't support MVC\n"</span>);
            <span class="keywordflow">return</span> -1;
        }
        <span class="keywordflow">if</span> (g_transcode_data.enc_settings.svc.multistream_mode == <a class="code" href="v4e__settings_8h.html#73683698f52b7fac59e9fa6cb29699a726c970ffcf8b4daf99fbe290f89e3e6b" title="SVC mode (default).">MULTISTREAM_MODE_SVC</a> &amp;&amp; g_transcode_data.transcode)
        {
            verbose_print(0, <span class="stringliteral">"Warning: Disable transcoding mode for SVC output\n"</span>);
            g_transcode_data.transcode = 0;
        }
    }

    <span class="keywordflow">if</span> (0 == sample_transcode_init(&amp;g_transcode_data))
        sample_transcode_run(&amp;g_transcode_data);

    sample_transcode_close(&amp;g_transcode_data);

<span class="preprocessor">#ifdef _CRT_DEBUG_</span>
<span class="preprocessor"></span>    _CrtMemCheckpoint(&amp;_ms2);
    _CrtMemDifference(&amp;_ms3, &amp;_ms1, &amp;_ms2);
    _CrtMemDumpStatistics(&amp;_ms3);
    _CrtDumpMemoryLeaks();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
}
</pre></div> </div>

<!-- footer.html -->
	<hr>

	<p style="font-size: smaller; text-align: right">
		&#169 <a href="http://www.vsofts.com/" target="_blank">Vanguard Software Solutions Inc</a> 1995-2011 - All rights reserved.
	</p>

	</body>
</html>
