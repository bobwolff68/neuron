<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="style.css" REL="stylesheet" TYPE="text/css">
</head>
    <BODY BGCOLOR="#FFFFFF">

	<a href="http://www.vsofts.com/" target="top">
		<img src="vssh-codec-logo.gif" border="none">
	</a>
	<p style="margin-top: 0px; font-size: smaller;">
		<a href="main.html" style="text-decoration:none; color: #252E78; ">
		VSS H.264 Encoder SDK v4
		</a>
	</p>
<!-- header.html -->

<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1>Decoder Functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g80a3db11fb6b7faa45f35b2e6a7ff89f">v4d_open</a> (void **phandle, <a class="el" href="structv4d__settings__t.html">v4d_settings_t</a> *settings)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new decoder instance.  <a href="#g80a3db11fb6b7faa45f35b2e6a7ff89f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g1115df23e02672729dc4e4dc2c51e334">v4d_can_accept_nal_unit</a> (void *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check, if decoder can accept new nal unit.  <a href="#g1115df23e02672729dc4e4dc2c51e334"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd">v4d_set_nal_unit</a> (void *handle, <a class="el" href="structmedia__sample__t.html">media_sample_t</a> *nal_unit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pass next nal unit into decoder.  <a href="#g41713b916283c31553b8d59d464004fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gf9ee658aeaa4e36510f7b0435643bf87">v4d_set_end_of_access_unit</a> (void *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Informs decoder, that all slices of current access unit are passed.  <a href="#gf9ee658aeaa4e36510f7b0435643bf87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gd9eeea5e54e450cc492f22aadeaea749">v4d_decode_sps</a> (void *handle, byte *sps_bytes, int num_sps_bytes, <a class="el" href="structsps__info__t.html">sps_info_t</a> *sps_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode SPS (sequence parameter set) NAL unit;.  <a href="#gd9eeea5e54e450cc492f22aadeaea749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g71d93564fa758bdf34df8bae48b6f688">v4d_decode_pps</a> (void *handle, byte *pps_bytes, int num_pps_bytes, <a class="el" href="structpps__info__t.html">pps_info_t</a> *pps_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode PPS (picture parameter set) NAL unit;.  <a href="#g71d93564fa758bdf34df8bae48b6f688"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmedia__sample__t.html">media_sample_t</a> *VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g18d3e30a1589fdae7789cc5da274cf23">v4d_get_decoded_nal_unit</a> (void *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the pointer to media sample with encapsulated decoded structure of last NAL-unit, set by <a class="el" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit()</a> function.  <a href="#g18d3e30a1589fdae7789cc5da274cf23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gecb40bc6c0ca39fddf179661217c10f5">v4d_set_nal_unit_and_decode</a> (void *handle, <a class="el" href="structmedia__sample__t.html">media_sample_t</a> *nal_unit, <a class="el" href="structmedia__sample__t.html">media_sample_t</a> **pdecoded_ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pass next nal unit into decoder, decode it's header and return pointer to encapsulated decoded structure See <a class="el" href="group__dec__func.html#g18d3e30a1589fdae7789cc5da274cf23" title="Return the pointer to media sample with encapsulated decoded structure of last NAL-unit...">v4d_get_decoded_nal_unit()</a> for more details about it This function is combination of <a class="el" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit()</a> and <a class="el" href="group__dec__func.html#g18d3e30a1589fdae7789cc5da274cf23" title="Return the pointer to media sample with encapsulated decoded structure of last NAL-unit...">v4d_get_decoded_nal_unit()</a> calls.  <a href="#gecb40bc6c0ca39fddf179661217c10f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gaf54a836e3db8ff25dee3e65f05f7bd2">v4d_film_grain</a> (void *handle, <a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *dec_frame)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Film grain filter implementation.  <a href="#gaf54a836e3db8ff25dee3e65f05f7bd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g4077cb1dee4a65ed5873f4929c046884">v4d_post_filter</a> (void *handle, <a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *dec_frame)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Post filter implementation.  <a href="#g4077cb1dee4a65ed5873f4929c046884"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g7beedf7d273a4a174589fc6245cc7e99">v4d_get_frame</a> (void *handle, <a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> **p_yuv_frame, <a class="el" href="structsps__info__t.html">sps_info_t</a> *sps_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to take next decoded frame.  <a href="#g7beedf7d273a4a174589fc6245cc7e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g8037b2427d03d7a889785548764ece46">v4d_get_frame_macroblocks_data</a> (void *handle, <a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *yuv_frame, <a class="el" href="structmedia__sample__t.html">media_sample_t</a> **pmbs_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get frame macroblocks data.  <a href="#g8037b2427d03d7a889785548764ece46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#ge16beaf3533ffed43a7945e5caaf09da">v4d_get_next_frame_view</a> (void *handle, <a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> **p_yuv_frame_next_view, <a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *yuv_frame_view, <a class="el" href="structsps__info__t.html">sps_info_t</a> *sps_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to take next view of decoded frame.  <a href="#ge16beaf3533ffed43a7945e5caaf09da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g4b8b1a6b459a3a426e79fe80c8cb345e">v4d_set_output_delay</a> (void *handle, int output_delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change output delay on-the-fly.  <a href="#g4b8b1a6b459a3a426e79fe80c8cb345e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#ga61ae04d7e83f191fd2a03d7186f96ec">v4d_close</a> (void *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close decoder, release memory etc.  <a href="#ga61ae04d7e83f191fd2a03d7186f96ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g9a18a41bbfa5fc81549b77a4b36584a5">v4d_nal_extractor_create_ex</a> (int initial_size, int remove_startcode_emulation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init input stream buffer.  <a href="#g9a18a41bbfa5fc81549b77a4b36584a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g5d92f8b8770a2c9f105eb4743f6fde9e">v4d_nal_extractor_create</a> (int initial_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init input stream buffer.  <a href="#g5d92f8b8770a2c9f105eb4743f6fde9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gbc0d7fbc4737482910f47a59a630ba16">v4d_nal_extractor_close</a> (void *extractor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release stream buffer.  <a href="#gbc0d7fbc4737482910f47a59a630ba16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g5183bf0f664750fd230af6672ed159f9">v4d_nal_extractor_feed_data</a> (void *extractor, byte *data, int size, int is_nal_unit, int64_t timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put RBSP bytes into stream buffer.  <a href="#g5183bf0f664750fd230af6672ed159f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gde803799b0cbfe6570f915f69cb5a8ab">v4d_nal_extractor_flush</a> (void *extractor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the extractor by forcing all incomplete NAL units go out on next call to get_nalu().  <a href="#gde803799b0cbfe6570f915f69cb5a8ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structmedia__sample__t.html">media_sample_t</a> *VSSHAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#g358f1867dbf318050228795349516520">v4d_nal_extractor_get_nalu</a> (void *extractor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract next NAL unit from the buffer (or NULL if nothing available) This nal unit must be either released by caller via <a class="el" href="v4__media__sample_8h.html#b9ff1ee2911ee3fd4fdb6dd497a91e0f" title="Free previously allocated media sample;.">v4_free_media_sample()</a> function or be put into decoder, decoder will free it automatically.  <a href="#g358f1867dbf318050228795349516520"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dec__func.html#gbe73f179f088c7cd068e1054ef5509f8">v4d_default_settings</a> (<a class="el" href="structv4d__settings__t.html">v4d_settings_t</a> *settings, int mt_disable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set default decoder settings.  <a href="#gbe73f179f088c7cd068e1054ef5509f8"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g1115df23e02672729dc4e4dc2c51e334"></a><!-- doxytag: member="v4d_api.h::v4d_can_accept_nal_unit" ref="g1115df23e02672729dc4e4dc2c51e334" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_can_accept_nal_unit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check, if decoder can accept new nal unit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder instance (returned by v4d_open) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK In this case decoder can accept new nal unit Otherwice - it can't </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga61ae04d7e83f191fd2a03d7186f96ec"></a><!-- doxytag: member="v4d_api.h::v4d_close" ref="ga61ae04d7e83f191fd2a03d7186f96ec" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_close           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close decoder, release memory etc. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- handle of the decoder instance (returned by <a class="el" href="group__dec__func.html#g80a3db11fb6b7faa45f35b2e6a7ff89f" title="Create a new decoder instance.">v4d_open()</a>); </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK or error code; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g71d93564fa758bdf34df8bae48b6f688"></a><!-- doxytag: member="v4d_api.h::v4d_decode_pps" ref="g71d93564fa758bdf34df8bae48b6f688" args="(void *handle, byte *pps_bytes, int num_pps_bytes, pps_info_t *pps_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_decode_pps           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pps_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_pps_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpps__info__t.html">pps_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pps_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode PPS (picture parameter set) NAL unit;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Handle of the decoder instance (returned by v4d_open); </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pps_bytes</em>&nbsp;</td><td>pointer to PPS bytes (RBSP format); </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_pps_bytes</em>&nbsp;</td><td>number of PPS bytes; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pps_info</em>&nbsp;</td><td>structure to receive decoded PPS information; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error code; </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd9eeea5e54e450cc492f22aadeaea749"></a><!-- doxytag: member="v4d_api.h::v4d_decode_sps" ref="gd9eeea5e54e450cc492f22aadeaea749" args="(void *handle, byte *sps_bytes, int num_sps_bytes, sps_info_t *sps_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_decode_sps           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>sps_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_sps_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsps__info__t.html">sps_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sps_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode SPS (sequence parameter set) NAL unit;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder instance (returned by v4d_open) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sps_bytes</em>&nbsp;</td><td>pointer to SPS bytes (RBSP format); </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_sps_bytes</em>&nbsp;</td><td>number of SPS bytes; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sps_info</em>&nbsp;</td><td>- structure to receive decoded SPS information; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error code; </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbe73f179f088c7cd068e1054ef5509f8"></a><!-- doxytag: member="v4d_settings.h::v4d_default_settings" ref="gbe73f179f088c7cd068e1054ef5509f8" args="(v4d_settings_t *settings, int mt_disable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void v4d_default_settings           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structv4d__settings__t.html">v4d_settings_t</a> *&nbsp;</td>
          <td class="paramname"> <em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mt_disable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set default decoder settings. 
<p>

</div>
</div><p>
<a class="anchor" name="gaf54a836e3db8ff25dee3e65f05f7bd2"></a><!-- doxytag: member="v4d_api.h::v4d_film_grain" ref="gaf54a836e3db8ff25dee3e65f05f7bd2" args="(void *handle, yuv_frame_t *dec_frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a>* VSSHAPI v4d_film_grain           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dec_frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Film grain filter implementation. 
<p>
Adds noise to given YUV frame according to film_grain SEI information (if any). Note that DEC_DECODE_SEI flag should be enabled in decoder settings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder handle; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dec_frame</em>&nbsp;</td><td>- pointer to decoded frame as returned by "v4d_get_frame()"; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to modified frame or NULL if errors </dd></dl>

</div>
</div><p>
<a class="anchor" name="g18d3e30a1589fdae7789cc5da274cf23"></a><!-- doxytag: member="v4d_api.h::v4d_get_decoded_nal_unit" ref="g18d3e30a1589fdae7789cc5da274cf23" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmedia__sample__t.html">media_sample_t</a>* VSSHAPI v4d_get_decoded_nal_unit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the pointer to media sample with encapsulated decoded structure of last NAL-unit, set by <a class="el" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit()</a> function. 
<p>
Depending on NAL-type it can be: <a class="el" href="structpic__parameter__set__t.html">pic_parameter_set_t</a> <a class="el" href="structslice__params__t.html">slice_params_t</a> <a class="el" href="structseq__parameter__set__t.html" title="Sequence Parameter Set structure.">seq_parameter_set_t</a> NAL type is placed into extra_data[3] byte of returned <a class="el" href="structmedia__sample__t.html">media_sample_t</a> structure For SEI NAL type it can be the list of several media samples, returned in the same manner, and with same properties, as attached to decoded frames (see sei_list field of <a class="el" href="structframe__info__t.html" title="Generic frame information.">frame_info_t</a> structure and DEC_DECODE_SEI flag) This pointer is valid until next call to <a class="el" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit()</a> function Application shall not free or modify data in this media_sample<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Handle of the decoder instance (returned by v4d_open); </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>media sample or NULL if errors or not supported NAL </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7beedf7d273a4a174589fc6245cc7e99"></a><!-- doxytag: member="v4d_api.h::v4d_get_frame" ref="g7beedf7d273a4a174589fc6245cc7e99" args="(void *handle, yuv_frame_t **p_yuv_frame, sps_info_t *sps_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_get_frame           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>p_yuv_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsps__info__t.html">sps_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sps_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to take next decoded frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_yuv_frame</em>&nbsp;</td><td>- where to put pointer to output frame </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sps_info</em>&nbsp;</td><td>- where to put sps info (can be NULL if not needed) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK=frame is ready; VSSH_WARN_NOT_READY=frame not ready; VSSH_WARN_EOS=end of stream (no more frames expected) </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8037b2427d03d7a889785548764ece46"></a><!-- doxytag: member="v4d_api.h::v4d_get_frame_macroblocks_data" ref="g8037b2427d03d7a889785548764ece46" args="(void *handle, yuv_frame_t *yuv_frame, media_sample_t **pmbs_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_get_frame_macroblocks_data           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>yuv_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmedia__sample__t.html">media_sample_t</a> **&nbsp;</td>
          <td class="paramname"> <em>pmbs_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get frame macroblocks data. 
<p>
This info can be used by encoder to make smart transcoding <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yuv_frame</em>&nbsp;</td><td>- yuv frame </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmbs_data</em>&nbsp;</td><td>- where to put pointer to media sample with macroblock data. Caller must release this media sample when done with it </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK or error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge16beaf3533ffed43a7945e5caaf09da"></a><!-- doxytag: member="v4d_api.h::v4d_get_next_frame_view" ref="ge16beaf3533ffed43a7945e5caaf09da" args="(void *handle, yuv_frame_t **p_yuv_frame_next_view, yuv_frame_t *yuv_frame_view, sps_info_t *sps_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_get_next_frame_view           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> **&nbsp;</td>
          <td class="paramname"> <em>p_yuv_frame_next_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>yuv_frame_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsps__info__t.html">sps_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sps_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to take next view of decoded frame. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_yuv_frame_next_view</em>&nbsp;</td><td>- where to put pointer to next output frame view </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yuv_frame_view</em>&nbsp;</td><td>- pointer to current output frame view </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sps_info</em>&nbsp;</td><td>- where to put sps info (can be NULL if not needed) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK=frame view is ready; VSSH_WARN_NOT_READY=frame view not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbc0d7fbc4737482910f47a59a630ba16"></a><!-- doxytag: member="v4d_api.h::v4d_nal_extractor_close" ref="gbc0d7fbc4737482910f47a59a630ba16" args="(void *extractor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_nal_extractor_close           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extractor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release stream buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>extractor</em>&nbsp;</td><td>- nal unit extractor instance; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error code; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5d92f8b8770a2c9f105eb4743f6fde9e"></a><!-- doxytag: member="v4d_api.h::v4d_nal_extractor_create" ref="g5d92f8b8770a2c9f105eb4743f6fde9e" args="(int initial_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSSHAPI v4d_nal_extractor_create           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initial_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init input stream buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initial_size</em>&nbsp;</td><td>- data buffer initial size; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to a structure created or NULL in case of out of memory; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9a18a41bbfa5fc81549b77a4b36584a5"></a><!-- doxytag: member="v4d_api.h::v4d_nal_extractor_create_ex" ref="g9a18a41bbfa5fc81549b77a4b36584a5" args="(int initial_size, int remove_startcode_emulation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSSHAPI v4d_nal_extractor_create_ex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>remove_startcode_emulation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init input stream buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initial_size</em>&nbsp;</td><td>- data buffer initial size; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remove_startcode_emulation</em>&nbsp;</td><td>- whether to remove 0x3 startcode preventing bytes; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to a structure created; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5183bf0f664750fd230af6672ed159f9"></a><!-- doxytag: member="v4d_api.h::v4d_nal_extractor_feed_data" ref="g5183bf0f664750fd230af6672ed159f9" args="(void *extractor, byte *data, int size, int is_nal_unit, int64_t timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_nal_extractor_feed_data           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extractor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_nal_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put RBSP bytes into stream buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>extractor</em>&nbsp;</td><td>- nal unit extractor instance; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- pointer to input bytes; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>- number of bytes; zero means the flush; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_nal_unit</em>&nbsp;</td><td>- indicate whole nal unit or raw bytes: 0 = raw bytes on input, the function will parse startcodes and do the rest; 1 = the function put bytes of one entire NAL unit into stream buffer; the data must not include startcodes. In this case this function will flush the previously accumulated data and copy all bytes into new internal nal units; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>Timestamp of the data (or NO_TIME_STAMP value if no timestmap) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="gde803799b0cbfe6570f915f69cb5a8ab"></a><!-- doxytag: member="v4d_api.h::v4d_nal_extractor_flush" ref="gde803799b0cbfe6570f915f69cb5a8ab" args="(void *extractor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_nal_extractor_flush           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extractor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush the extractor by forcing all incomplete NAL units go out on next call to get_nalu(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>extractor</em>&nbsp;</td><td>- nal unit extractor instance; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK </dd></dl>

</div>
</div><p>
<a class="anchor" name="g358f1867dbf318050228795349516520"></a><!-- doxytag: member="v4d_api.h::v4d_nal_extractor_get_nalu" ref="g358f1867dbf318050228795349516520" args="(void *extractor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmedia__sample__t.html">media_sample_t</a>* VSSHAPI v4d_nal_extractor_get_nalu           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extractor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract next NAL unit from the buffer (or NULL if nothing available) This nal unit must be either released by caller via <a class="el" href="v4__media__sample_8h.html#b9ff1ee2911ee3fd4fdb6dd497a91e0f" title="Free previously allocated media sample;.">v4_free_media_sample()</a> function or be put into decoder, decoder will free it automatically. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>extractor</em>&nbsp;</td><td>- nal unit extractor instance; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NAL unit or NULL if nothing ready; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g80a3db11fb6b7faa45f35b2e6a7ff89f"></a><!-- doxytag: member="v4d_api.h::v4d_open" ref="g80a3db11fb6b7faa45f35b2e6a7ff89f" args="(void **phandle, v4d_settings_t *settings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_open           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>phandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structv4d__settings__t.html">v4d_settings_t</a> *&nbsp;</td>
          <td class="paramname"> <em>settings</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new decoder instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phandle</em>&nbsp;</td><td>- pointer to a variable which will receive decoder handle in case of success, can not be NULL; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>settings</em>&nbsp;</td><td>- pointer to the <a class="el" href="structv4d__settings__t.html">v4d_settings_t</a> structure containing initial decoder parameters to be used during this session. Note: can not be NULL. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK=success, VSSH_ERR_ARG=invalid argument (NULL), VSSH_ERR_SETTINGS=incorrect settings, VSSH_ERR_MEMORY=out of memory; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4077cb1dee4a65ed5873f4929c046884"></a><!-- doxytag: member="v4d_api.h::v4d_post_filter" ref="g4077cb1dee4a65ed5873f4929c046884" args="(void *handle, yuv_frame_t *dec_frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a>* VSSHAPI v4d_post_filter           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structyuv__frame__t.html">yuv_frame_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dec_frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Post filter implementation. 
<p>
Improve quality of the given YUV frame with Wiener optimal filter. Note that DEC_DECODE_SEI flag should be enabled in decoder settings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder handle; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dec_frame</em>&nbsp;</td><td>- pointer to decoded frame as returned by "v4d_get_frame()"; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to modified frame or NULL if errors </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf9ee658aeaa4e36510f7b0435643bf87"></a><!-- doxytag: member="v4d_api.h::v4d_set_end_of_access_unit" ref="gf9ee658aeaa4e36510f7b0435643bf87" args="(void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_set_end_of_access_unit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Informs decoder, that all slices of current access unit are passed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder instance (returned by v4d_open) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK=success, or error code </dd></dl>

</div>
</div><p>
<a class="anchor" name="g41713b916283c31553b8d59d464004fd"></a><!-- doxytag: member="v4d_api.h::v4d_set_nal_unit" ref="g41713b916283c31553b8d59d464004fd" args="(void *handle, media_sample_t *nal_unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_set_nal_unit           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmedia__sample__t.html">media_sample_t</a> *&nbsp;</td>
          <td class="paramname"> <em>nal_unit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pass next nal unit into decoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder instance (returned by v4d_open) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nal_unit</em>&nbsp;</td><td>- input NAL unit in RBSP format (no start code at the beginning, no start codes inside), pass NULL to signal end of stream; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK=success, In this case decoder will take care to release it when all is done; In case of error the caller must release "nal_unit" by itself; </dd></dl>

</div>
</div><p>
<a class="anchor" name="gecb40bc6c0ca39fddf179661217c10f5"></a><!-- doxytag: member="v4d_api.h::v4d_set_nal_unit_and_decode" ref="gecb40bc6c0ca39fddf179661217c10f5" args="(void *handle, media_sample_t *nal_unit, media_sample_t **pdecoded_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_set_nal_unit_and_decode           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmedia__sample__t.html">media_sample_t</a> *&nbsp;</td>
          <td class="paramname"> <em>nal_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmedia__sample__t.html">media_sample_t</a> **&nbsp;</td>
          <td class="paramname"> <em>pdecoded_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pass next nal unit into decoder, decode it's header and return pointer to encapsulated decoded structure See <a class="el" href="group__dec__func.html#g18d3e30a1589fdae7789cc5da274cf23" title="Return the pointer to media sample with encapsulated decoded structure of last NAL-unit...">v4d_get_decoded_nal_unit()</a> for more details about it This function is combination of <a class="el" href="group__dec__func.html#g41713b916283c31553b8d59d464004fd" title="Pass next nal unit into decoder.">v4d_set_nal_unit()</a> and <a class="el" href="group__dec__func.html#g18d3e30a1589fdae7789cc5da274cf23" title="Return the pointer to media sample with encapsulated decoded structure of last NAL-unit...">v4d_get_decoded_nal_unit()</a> calls. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder instance (returned by v4d_open) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nal_unit</em>&nbsp;</td><td>- input NAL unit in RBSP format (no start code at the beginning, no start codes inside), </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pdecoded_ms</em>&nbsp;</td><td>- pointer where to put result </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK=success, In this case decoder will take care to release nal_unit when all is done; In case of error the caller must release "nal_unit" by itself; </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4b8b1a6b459a3a426e79fe80c8cb345e"></a><!-- doxytag: member="v4d_api.h::v4d_set_output_delay" ref="g4b8b1a6b459a3a426e79fe80c8cb345e" args="(void *handle, int output_delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSSHAPI v4d_set_output_delay           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>output_delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change output delay on-the-fly. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>- decoder instance (returned by v4d_open) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_delay</em>&nbsp;</td><td>- new value of output delay; -1 - means "calulate" from active sps </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>VSSH_OK = success, or error code </dd></dl>

</div>
</div><p>
</div>

<!-- footer.html -->
	<hr>

	<p style="font-size: smaller; text-align: right">
		&#169 <a href="http://www.vsofts.com/" target="_blank">Vanguard Software Solutions Inc</a> 1995-2011 - All rights reserved.
	</p>

	</body>
</html>
